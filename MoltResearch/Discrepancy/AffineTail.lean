import MoltResearch.Discrepancy.Affine
import MoltResearch.Discrepancy.Offset

/-!
# Discrepancy: tail/splitting lemmas for `apSumFrom`

(Generated by Forge.)
-/

namespace MoltResearch

/-- Difference of two affine AP partial sums as a tail sum when `m ≤ n`. -/
lemma apSumFrom_sub_apSumFrom_eq_apSumFrom (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumFrom f (a + m * d) d (n - m) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sub (f := f) (a := a) (d := d) (m := m) (n := n - m)).symm

/-- Difference of a longer affine AP partial sum and its initial segment, in the `(m + n) - m`
normal form.

This lemma is a convenience wrapper around `apSumFrom_tail_eq_sub`, oriented so that rewriting
turns a subtraction into an explicit tail sum.
-/
lemma apSumFrom_sub_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (a + m * d) d n := by
  simpa using (apSumFrom_tail_eq_sub (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Tail-of-tail normal form: subtracting two affine tail sums yields a later tail sum. -/
lemma apSumFrom_tail_sub_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumFrom f (a + (m + n1) * d) d n2 := by
  have h :=
    apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a + m * d) (d := d) (m := n1) (n := n2)
  have hstart : (a + m * d) + n1 * d = a + (m + n1) * d := by
    calc
      (a + m * d) + n1 * d = a + (m * d + n1 * d) := by
        simp [Nat.add_assoc]
      _ = a + (m + n1) * d := by
        simpa using congrArg (fun t => a + t) (Nat.add_mul m n1 d).symm
  simpa [hstart] using h

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (a + k)`. -/
lemma apSumFrom_tail_eq_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
  classical
  unfold apSumFrom apSumOffset
  refine Finset.sum_congr rfl ?_
  intro i hi
  have hmul : m * d + (i + 1) * d = (m + i + 1) * d := by
    -- `Nat.add_mul` gives `(m + (i+1)) * d = m*d + (i+1)*d`.
    -- We use it backwards and normalize `m + (i+1)` to `m + i + 1`.
    simpa [Nat.add_assoc] using (Nat.add_mul m (i + 1) d).symm
  calc
    f ((a + m * d) + (i + 1) * d) = f (a + (m * d + (i + 1) * d)) := by
      simp [Nat.add_assoc]
    _ = f (a + ((m + i + 1) * d)) := by
      simp [hmul]

/-- Tail-of-tail normal form, expressed as an offset AP sum on the shifted sequence `k ↦ f (a + k)`.

This is the `apSumFrom` analogue of `apSumOffset_sub_eq_apSumOffset_tail`.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1
        = apSumFrom f (a + (m + n1) * d) d n2 := by
            simpa using
              (apSumFrom_tail_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m)
                (n1 := n1) (n2 := n2))
    _ = apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m + n1)
                (n := n2))

/-- Normal form: rewrite the canonical affine difference `(m+n) - m` as an offset AP sum on the
shifted sequence `k ↦ f (a + k)`.

This is the `apSumFrom` analogue of `apSum_sub_eq_apSumOffset`, oriented so that rewriting turns a
subtraction into an explicit `apSumOffset` tail.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Rewrite the affine tail sum `apSumFrom f (a + m*d) d n` as the “paper notation” interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)`.

This is intended for surface statements: keep the nucleus API in terms of `apSumFrom` and use
this lemma only when matching paper notation.
-/
lemma apSumFrom_tail_eq_sum_Icc (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
      simpa using
        (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- Difference of two affine AP partial sums as an offset AP sum on the shifted sequence
`k ↦ f (a + k)` when `m ≤ n`.

This is the affine analogue of `apSum_sub_apSum_eq_apSumOffset`.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m)
                (n := n - m))

/-- Rewrite the normal-form difference `apSumFrom f a d (m+n) - apSumFrom f a d m` as an
interval sum `∑ i ∈ Icc (m+1) (m+n), f (a + i*d)`.

This is intended for surface statements: keep the nucleus API in terms of `apSumFrom` and use
this lemma only when matching paper notation.
-/
lemma apSumFrom_sub_eq_sum_Icc (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
            simpa using
              (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- When `m ≤ n`, rewrite `apSumFrom f a d n - apSumFrom f a d m` as an interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)`.

This is the “paper notation” counterpart of `apSumFrom_sub_apSumFrom_eq_apSumFrom`.
-/
lemma apSumFrom_sub_apSumFrom_eq_sum_Icc (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m)
                (n := n - m))
    _ = (Finset.Icc (m + 1) (m + (n - m))).sum (fun i => f (a + i * d)) := by
            simpa using
              (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n - m))
    _ = (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
            simp [Nat.add_sub_of_le hmn]

/-- Sign-sequence bound on `apSumFrom` in the `(m + n) - m` normal form. -/
lemma IsSignSequence.natAbs_apSumFrom_sub_le {f : ℕ → ℤ} (hf : IsSignSequence f)
    (a d m n : ℕ) :
    Int.natAbs (apSumFrom f a d (m + n) - apSumFrom f a d m) ≤ n := by
  have h := IsSignSequence.natAbs_apSumFrom_le (hf := hf) (a := a + m * d) (d := d) (n := n)
  have hEq := apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n)
  simpa [hEq] using h

/-- Split an affine AP partial sum at `m` when `m ≤ n`. -/
lemma apSumFrom_eq_add_apSumFrom_tail (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n = apSumFrom f a d m + apSumFrom f (a + m * d) d (n - m) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_add_length (f:=f) (a:=a) (d:=d) (m:=m) (n:=n - m))

/-- Sign-sequence bound on the difference of two affine AP partial sums when `m ≤ n`. -/
lemma IsSignSequence.natAbs_apSumFrom_sub_apSumFrom_le {f : ℕ → ℤ} (hf : IsSignSequence f)
    (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    Int.natAbs (apSumFrom f a d n - apSumFrom f a d m) ≤ n - m := by
  have h := IsSignSequence.natAbs_apSumFrom_le (hf := hf) (a := a + m * d) (d := d) (n := n - m)
  have hEq := apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn)
  simpa [hEq] using h

end MoltResearch
