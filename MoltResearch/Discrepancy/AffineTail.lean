import MoltResearch.Discrepancy.Affine
import MoltResearch.Discrepancy.Offset

/-!
# Discrepancy: tail/splitting lemmas for `apSumFrom`

(Generated by Forge.)
-/

namespace MoltResearch

/-- Head+tail normal form for affine tails: the first term is `f (a + (m+1)*d)`.

This is the affine-tail analogue of `apSumOffset_succ_length`, convenient when you want to
increment the tail parameter `m` explicitly.
-/
lemma apSumFrom_tail_succ_length (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) =
      f (a + (m + 1) * d) + apSumFrom f (a + (m + 1) * d) d n := by
  -- Start from the generic `apSumFrom_succ_length` and normalize the start point.
  have h := apSumFrom_succ_length (f := f) (a := a + m * d) (d := d) (n := n)
  -- Normalize `(a + m*d) + d` to `a + (m+1)*d`.
  have hstart : (a + m * d) + d = a + (m + 1) * d := by
    calc
      (a + m * d) + d = a + (m * d + d) := by
        simp [Nat.add_assoc]
      _ = a + (m + 1) * d := by
        simpa [Nat.add_assoc, Nat.one_mul] using congrArg (fun t => a + t) (Nat.add_mul m 1 d).symm
  simpa [hstart] using h

/-- Difference of two affine AP partial sums as a tail sum when `m ≤ n`. -/
lemma apSumFrom_sub_apSumFrom_eq_apSumFrom (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumFrom f (a + m * d) d (n - m) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sub (f := f) (a := a) (d := d) (m := m) (n := n - m)).symm

/-- Difference of a longer affine AP partial sum and its initial segment, in the `(m + n) - m`
normal form.

This lemma is a convenience wrapper around `apSumFrom_tail_eq_sub`, oriented so that rewriting
turns a subtraction into an explicit tail sum.
-/
lemma apSumFrom_sub_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (a + m * d) d n := by
  simpa using (apSumFrom_tail_eq_sub (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Tail-of-tail normal form: subtracting two affine tail sums yields a later tail sum. -/
lemma apSumFrom_tail_sub_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumFrom f (a + (m + n1) * d) d n2 := by
  have h :=
    apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a + m * d) (d := d) (m := n1) (n := n2)
  have hstart : (a + m * d) + n1 * d = a + (m + n1) * d := by
    calc
      (a + m * d) + n1 * d = a + (m * d + n1 * d) := by
        simp [Nat.add_assoc]
      _ = a + (m + n1) * d := by
        simpa using congrArg (fun t => a + t) (Nat.add_mul m n1 d).symm
  simpa [hstart] using h

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (a + k)`. -/
lemma apSumFrom_tail_eq_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
  classical
  unfold apSumFrom apSumOffset
  refine Finset.sum_congr rfl ?_
  intro i hi
  have hmul : m * d + (i + 1) * d = (m + i + 1) * d := by
    -- `Nat.add_mul` gives `(m + (i+1)) * d = m*d + (i+1)*d`.
    -- We use it backwards and normalize `m + (i+1)` to `m + i + 1`.
    simpa [Nat.add_assoc] using (Nat.add_mul m (i + 1) d).symm
  calc
    f ((a + m * d) + (i + 1) * d) = f (a + (m * d + (i + 1) * d)) := by
      simp [Nat.add_assoc]
    _ = f (a + ((m + i + 1) * d)) := by
      simp [hmul]

/-- Affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (a + k)`.

This is the `m = 0` case of `apSumFrom_tail_eq_apSumOffset_shift`.
-/
lemma apSumFrom_eq_apSumOffset_shift (f : ℕ → ℤ) (a d n : ℕ) :
    apSumFrom f a d n = apSumOffset (fun k => f (a + k)) d 0 n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := 0) (n := n))

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is the same normal form as `apSumFrom_tail_eq_apSumOffset_shift`, but the shifted sequence is
written in the translation-friendly `k + a` form.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (k + a)) d m n := by
  have hshift : (fun k => f (a + k)) = (fun k => f (k + a)) := by
    funext k
    simpa using congrArg f (Nat.add_comm a k)
  simpa [hshift] using
    (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is the `m = 0` case of `apSumFrom_tail_eq_apSumOffset_shift_add`.
-/
lemma apSumFrom_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d n : ℕ) :
    apSumFrom f a d n = apSumOffset (fun k => f (k + a)) d 0 n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := 0) (n := n))

/-- Normal form: rewrite the canonical affine difference `(m+n) - m` as an offset AP sum on the
shifted sequence `k ↦ f (k + a)`.

This is the same normal form as `apSumFrom_sub_eq_apSumOffset_shift`, but in the translation-
friendly `k + a` form.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumOffset (fun k => f (k + a)) d m n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (k + a)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
                (n := n))

/-- Tail-of-tail normal form, expressed as an offset AP sum on the shifted sequence `k ↦ f (a + k)`.

This is the `apSumFrom` analogue of `apSumOffset_sub_eq_apSumOffset_tail`.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1
        = apSumFrom f (a + (m + n1) * d) d n2 := by
            simpa using
              (apSumFrom_tail_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m)
                (n1 := n1) (n2 := n2))
    _ = apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m + n1)
                (n := n2))

/-- Tail-of-tail normal form, expressed as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is the translation-friendly `k + a` variant of `apSumFrom_tail_sub_eq_apSumOffset_shift_tail`.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_add_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
  have hshift : (fun k => f (a + k)) = (fun k => f (k + a)) := by
    funext k
    simpa using congrArg f (Nat.add_comm a k)
  simpa [hshift] using
    (apSumFrom_tail_sub_eq_apSumOffset_shift_tail (f := f) (a := a) (d := d) (m := m) (n1 := n1)
      (n2 := n2))

/-- Normal form: rewrite the canonical affine difference `(m+n) - m` as an offset AP sum on the
shifted sequence `k ↦ f (a + k)`.

This is the `apSumFrom` analogue of `apSum_sub_eq_apSumOffset`, oriented so that rewriting turns a
subtraction into an explicit `apSumOffset` tail.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Rewrite the affine tail sum `apSumFrom f (a + m*d) d n` as the “paper notation” interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)`.

This is intended for surface statements: keep the nucleus API in terms of `apSumFrom` and use
this lemma only when matching paper notation.
-/
lemma apSumFrom_tail_eq_sum_Icc (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
      simpa using
        (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- Normal form: rewrite the “paper notation” interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)` back to the affine tail sum `apSumFrom f (a + m*d) d n`.

This is useful when normalizing a surface statement into the nucleus API.
-/
lemma sum_Icc_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Split the “paper notation” affine interval sum
`∑ i ∈ Icc (m+1) (m+(n₁+n₂)), f (a + i*d)` into the first `n₁` terms and the next `n₂` terms.

This is the affine counterpart of `Discrepancy.sum_Icc_add_length`.
-/
lemma sum_Icc_add_length_affine (f : ℕ → ℤ) (a d m n₁ n₂ : ℕ) :
    (Finset.Icc (m + 1) (m + (n₁ + n₂))).sum (fun i => f (a + i * d)) =
      (Finset.Icc (m + 1) (m + n₁)).sum (fun i => f (a + i * d)) +
        (Finset.Icc (m + n₁ + 1) (m + n₁ + n₂)).sum (fun i => f (a + i * d)) := by
  -- Reduce to the non-affine splitting lemma by viewing `i ↦ f (a + i*d)` as the summand.
  simpa using
    (MoltResearch.sum_Icc_add_length (f := fun i => f (a + i)) (d := d) (m := m) (n₁ := n₁)
      (n₂ := n₂))

/-- Normal form: when `m ≤ n`, rewrite the “paper notation” interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)` to the affine tail sum `apSumFrom f (a + m*d) d (n - m)`.

This is the affine analogue of `sum_Icc_eq_apSumOffset`.
-/
lemma sum_Icc_eq_apSumFrom_tail_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) =
      apSumFrom f (a + m * d) d (n - m) := by
  -- Put the interval endpoint into the canonical `(m + (n - m))` form and use
  -- `sum_Icc_eq_apSumFrom_tail`.
  simpa [Nat.add_sub_of_le hmn] using
    (sum_Icc_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Surface form: when `m ≤ n`, rewrite the affine tail sum `apSumFrom f (a + m*d) d (n - m)` as
an interval sum `∑ i ∈ Icc (m+1) n, f (a + i*d)`.

This is the affine analogue of `apSumOffset_eq_sum_Icc_of_le`.
-/
lemma apSumFrom_tail_eq_sum_Icc_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f (a + m * d) d (n - m) =
      (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Difference of two affine AP partial sums as an offset AP sum on the shifted sequence
`k ↦ f (a + k)` when `m ≤ n`.

This is the affine analogue of `apSum_sub_apSum_eq_apSumOffset`.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m)
                (n := n - m))

/-- Difference of two affine AP partial sums as an offset AP sum on the shifted sequence
`k ↦ f (k + a)` when `m ≤ n`.

This is the same normal form as `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift`, but in the
translation-friendly `k + a` form.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (k + a)) d m (n - m) := by
  have hshift : (fun k => f (a + k)) = (fun k => f (k + a)) := by
    funext k
    simpa using congrArg f (Nat.add_comm a k)
  simpa [hshift] using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f := f) (a := a) (d := d) (hmn := hmn))

/-- Rewrite the normal-form difference `apSumFrom f a d (m+n) - apSumFrom f a d m` as an
interval sum `∑ i ∈ Icc (m+1) (m+n), f (a + i*d)`.

This is intended for surface statements: keep the nucleus API in terms of `apSumFrom` and use
this lemma only when matching paper notation.
-/
lemma apSumFrom_sub_eq_sum_Icc (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
            simpa using
              (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- When `m ≤ n`, rewrite `apSumFrom f a d n - apSumFrom f a d m` as an interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)`.

This is the “paper notation” counterpart of `apSumFrom_sub_apSumFrom_eq_apSumFrom`.
-/
lemma apSumFrom_sub_apSumFrom_eq_sum_Icc (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m)
                (n := n - m))
    _ = (Finset.Icc (m + 1) (m + (n - m))).sum (fun i => f (a + i * d)) := by
            simpa using
              (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n - m))
    _ = (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
            simp [Nat.add_sub_of_le hmn]

/-- Normal form (paper → nucleus, difference): rewrite the interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)` as the difference of affine AP partial sums.

This is the inverse orientation of `apSumFrom_sub_eq_sum_Icc`.
-/
lemma sum_Icc_eq_apSumFrom_sub (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) =
      apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using (apSumFrom_sub_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Normal form (paper → nucleus, difference): when `m ≤ n`, rewrite the interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)` as a difference of affine AP partial sums.

This is the inverse orientation of `apSumFrom_sub_apSumFrom_eq_sum_Icc`.
-/
lemma sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) =
      apSumFrom f a d n - apSumFrom f a d m := by
  simpa using (apSumFrom_sub_apSumFrom_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)
    hmn).symm

/-- Sign-sequence bound on `apSumFrom` in the `(m + n) - m` normal form. -/
lemma IsSignSequence.natAbs_apSumFrom_sub_le {f : ℕ → ℤ} (hf : IsSignSequence f)
    (a d m n : ℕ) :
    Int.natAbs (apSumFrom f a d (m + n) - apSumFrom f a d m) ≤ n := by
  have h := IsSignSequence.natAbs_apSumFrom_le (hf := hf) (a := a + m * d) (d := d) (n := n)
  have hEq := apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n)
  simpa [hEq] using h

/-- Split an affine AP partial sum at `m` when `m ≤ n`. -/
lemma apSumFrom_eq_add_apSumFrom_tail (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n = apSumFrom f a d m + apSumFrom f (a + m * d) d (n - m) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_add_length (f:=f) (a:=a) (d:=d) (m:=m) (n:=n - m))

/-- Sign-sequence bound on the difference of two affine AP partial sums when `m ≤ n`. -/
lemma IsSignSequence.natAbs_apSumFrom_sub_apSumFrom_le {f : ℕ → ℤ} (hf : IsSignSequence f)
    (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    Int.natAbs (apSumFrom f a d n - apSumFrom f a d m) ≤ n - m := by
  have h := IsSignSequence.natAbs_apSumFrom_le (hf := hf) (a := a + m * d) (d := d) (n := n - m)
  have hEq := apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn)
  simpa [hEq] using h

end MoltResearch
