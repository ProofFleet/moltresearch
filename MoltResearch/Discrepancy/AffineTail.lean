import MoltResearch.Discrepancy.Affine
import MoltResearch.Discrepancy.Offset

/-!
# Discrepancy: tail/splitting lemmas for `apSumFrom`

(Generated by Forge.)
-/

namespace MoltResearch

/-- Head+tail normal form for affine tails: the first term is `f (a + (m+1)*d)`.

This is the affine-tail analogue of `apSumOffset_succ_length`, convenient when you want to
increment the tail parameter `m` explicitly.
-/
lemma apSumFrom_tail_succ_length (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) =
      f (a + (m + 1) * d) + apSumFrom f (a + (m + 1) * d) d n := by
  -- Start from the generic `apSumFrom_succ_length` and normalize the start point.
  have h := apSumFrom_succ_length (f := f) (a := a + m * d) (d := d) (n := n)
  -- Normalize `(a + m*d) + d` to `a + (m+1)*d`.
  have hstart : (a + m * d) + d = a + (m + 1) * d := by
    calc
      (a + m * d) + d = a + (m * d + d) := by
        simp [Nat.add_assoc]
      _ = a + (m + 1) * d := by
        simpa [Nat.add_assoc, Nat.one_mul] using congrArg (fun t => a + t) (Nat.add_mul m 1 d).symm
  simpa [hstart] using h

/-- Translation-friendly variant of `apSumFrom_tail_succ_length`, with the affine term written as
`(m+1)*d + a`.

This avoids needing `Nat.add_comm` under `simp` goals in downstream proof scripts.
-/
lemma apSumFrom_tail_succ_length_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) =
      f ((m + 1) * d + a) + apSumFrom f ((m + 1) * d + a) d n := by
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_tail_succ_length (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Head+tail normal form for affine tails, with the start written as `m*d + a`.

This is a convenience wrapper around `apSumFrom_tail_succ_length_add_left` that avoids commuting
`a + m*d` at the call site.
-/
lemma apSumFrom_tail_succ_length_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d (n + 1) =
      f ((m + 1) * d + a) + apSumFrom f ((m + 1) * d + a) d n := by
  -- Normalize the affine start into the `a + m*d` form, apply the tail lemma, then normalize back.
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_tail_succ_length_add_left (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Right-end “append one term” normal form for affine tails.

This is the affine-tail analogue of `apSumOffset_succ`: it splits off the *last* term of the tail.
It is convenient when you want to induct on the length `n` while keeping the tail parameter `m`
fixed.
-/
lemma apSumFrom_tail_succ (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) = apSumFrom f (a + m * d) d n + f (a + (m + n + 1) * d) := by
  -- Start from the generic `apSumFrom_succ` and normalize the start point.
  have h := apSumFrom_succ (f := f) (a := a + m * d) (d := d) (n := n)
  -- Normalize `(a + m*d) + (n+1)*d` to `a + (m+n+1)*d`.
  have hlast : (a + m * d) + (n + 1) * d = a + (m + n + 1) * d := by
    calc
      (a + m * d) + (n + 1) * d = a + (m * d + (n + 1) * d) := by
        simp [Nat.add_assoc]
      _ = a + ((m + (n + 1)) * d) := by
        simpa using congrArg (fun t => a + t) (Nat.add_mul m (n + 1) d).symm
      _ = a + (m + n + 1) * d := by
        simp [Nat.add_assoc]
  simpa [hlast, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using h

/-- Translation-friendly variant of `apSumFrom_tail_succ`, with the affine term written as
`(m+n+1)*d + a`.

This is convenient when rewriting goals so that `simp` doesn't need to commute addition inside `f`.
-/
lemma apSumFrom_tail_succ_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) = apSumFrom f (a + m * d) d n + f ((m + n + 1) * d + a) := by
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_tail_succ (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Right-end “append one term” normal form for affine tails, with the start written as `m*d + a`.

This is a convenience wrapper around `apSumFrom_tail_succ_add_left` that avoids commuting
`a + m*d` at the call site.
-/
lemma apSumFrom_tail_succ_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d (n + 1) = apSumFrom f (m * d + a) d n + f ((m + n + 1) * d + a) := by
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_tail_succ_add_left (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Split an affine tail sum by length.

This is the affine-tail analogue of `apSum_add_length`/`apSumOffset_add_length`, expressed with an
explicit tail parameter `m`.
-/
lemma apSumFrom_tail_add_length (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) =
      apSumFrom f (a + m * d) d n1 + apSumFrom f (a + (m + n1) * d) d n2 := by
  have h := apSumFrom_add_length (f := f) (a := a + m * d) (d := d) (m := n1) (n := n2)
  have hstart : (a + m * d) + n1 * d = a + (m + n1) * d := by
    calc
      (a + m * d) + n1 * d = a + (m * d + n1 * d) := by
        simp [Nat.add_assoc]
      _ = a + (m + n1) * d := by
        simpa using congrArg (fun t => a + t) (Nat.add_mul m n1 d).symm
  simpa [hstart] using h


/-- Split an affine tail sum by length, with the affine start written as `m*d + a`.

This wrapper avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_tail_add_length_start_add_left (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (m * d + a) d (n1 + n2) =
      apSumFrom f (m * d + a) d n1 + apSumFrom f ((m + n1) * d + a) d n2 := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_add_length (f := f) (a := a) (d := d) (m := m) (n1 := n1) (n2 := n2))

/-- Difference of two affine AP partial sums as a tail sum when `m ≤ n`. -/
lemma apSumFrom_sub_apSumFrom_eq_apSumFrom (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumFrom f (a + m * d) d (n - m) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sub (f := f) (a := a) (d := d) (m := m) (n := n - m)).symm

/-- Convenience wrapper around `apSumFrom_sub_apSumFrom_eq_apSumFrom` with the tail start written as
`m*d + a`.

This avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumFrom_start_add_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumFrom f (m * d + a) d (n - m) := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))

/-- Difference of two affine AP partial sums as a step-one `apSum` normal form when `m ≤ n`.

This is a translation-friendly variant where the summand is written as `d * k + const`.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSum_step_one_mul_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      apSum (fun k => f (d * k + (m * d + a))) 1 (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (m * d + a) d (n - m) :=
          apSumFrom_sub_apSumFrom_eq_apSumFrom_start_add_left (f := f) (a := a) (d := d)
            (m := m) (n := n) hmn
    _ = apSum (fun k => f (d * k + (m * d + a))) 1 (n - m) := by
          -- `apSumFrom_eq_apSum_step_one_add_left` yields a `k * d + _` summand; commute to `d * k`.
          simpa [Nat.mul_comm, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
            (apSumFrom_eq_apSum_step_one_add_left (f := f) (a := m * d + a) (d := d)
              (n := n - m))

/-- Convenience wrapper around `apSumFrom_sub_apSumFrom_eq_apSum_step_one_mul_left` with the
constant written as `a + d*m` (mul-left orientation).

This is convenient when downstream goals already use the `a + d*m` normal form.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSum_step_one_mul_left_mul_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      apSum (fun k => f (d * k + (a + d * m))) 1 (n - m) := by
  simpa [Nat.mul_comm, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_apSumFrom_eq_apSum_step_one_mul_left (f := f) (a := a) (d := d)
      (m := m) (n := n) hmn)

/-- Difference of a longer affine AP partial sum and its initial segment, in the `(m + n) - m`
normal form.

This lemma is a convenience wrapper around `apSumFrom_tail_eq_sub`, oriented so that rewriting
turns a subtraction into an explicit tail sum.
-/
lemma apSumFrom_sub_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (a + m * d) d n := by
  simpa using (apSumFrom_tail_eq_sub (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Convenience wrapper around `apSumFrom_sub_eq_apSumFrom_tail` with the tail start written as
`m*d + a`.

This avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_sub_eq_apSumFrom_tail_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (m * d + a) d n := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Convenience wrapper around `apSumFrom_sub_eq_apSumFrom_tail` with the tail start written as
`a + d*m`.

This avoids commuting `m*d` into the mul-left orientation at the call site.
-/
lemma apSumFrom_sub_eq_apSumFrom_tail_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (a + d * m) d n := by
  simpa [Nat.mul_comm] using
    (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Tail-of-tail normal form: subtracting two affine tail sums yields a later tail sum. -/
lemma apSumFrom_tail_sub_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumFrom f (a + (m + n1) * d) d n2 := by
  have h :=
    apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a + m * d) (d := d) (m := n1) (n := n2)
  have hstart : (a + m * d) + n1 * d = a + (m + n1) * d := by
    calc
      (a + m * d) + n1 * d = a + (m * d + n1 * d) := by
        simp [Nat.add_assoc]
      _ = a + (m + n1) * d := by
        simpa using congrArg (fun t => a + t) (Nat.add_mul m n1 d).symm
  simpa [hstart] using h

/-- Tail-of-tail normal form with the affine start written as `m*d + a`.

This is a convenience wrapper around `apSumFrom_tail_sub_eq_apSumFrom_tail` that avoids a manual
commutativity rewrite of the affine start at the call site.
-/
lemma apSumFrom_tail_sub_eq_apSumFrom_tail_start_add_left (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (m * d + a) d (n1 + n2) - apSumFrom f (m * d + a) d n1 =
      apSumFrom f ((m + n1) * d + a) d n2 := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n1 := n1)
      (n2 := n2))

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (a + k)`. -/
lemma apSumFrom_tail_eq_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
  classical
  unfold apSumFrom apSumOffset
  refine Finset.sum_congr rfl ?_
  intro i hi
  have hmul : m * d + (i + 1) * d = (m + i + 1) * d := by
    -- `Nat.add_mul` gives `(m + (i+1)) * d = m*d + (i+1)*d`.
    -- We use it backwards and normalize `m + (i+1)` to `m + i + 1`.
    simpa [Nat.add_assoc] using (Nat.add_mul m (i + 1) d).symm
  calc
    f ((a + m * d) + (i + 1) * d) = f (a + (m * d + (i + 1) * d)) := by
      simp [Nat.add_assoc]
    _ = f (a + ((m + i + 1) * d)) := by
      simp [hmul]

/-- Head+tail splitting normal form for affine sums, with the tail expressed as an `apSumOffset`
on the shifted sequence `k ↦ f (a + k)`.

This is a convenience wrapper around `apSumFrom_add_length` and
`apSumFrom_tail_eq_apSumOffset_shift` that puts the tail into the offset-sum nucleus API directly.
-/
lemma apSumFrom_add_length_eq_add_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSumOffset (fun k => f (a + k)) d m n := by
  calc
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSumFrom f (a + m * d) d n := by
      simpa using apSumFrom_add_length (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumFrom f a d m + apSumOffset (fun k => f (a + k)) d m n := by
      simp [apSumFrom_tail_eq_apSumOffset_shift]

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (a + k)`, with the
starting point written as `m*d + a`.

This wrapper avoids a manual commutativity rewrite of the affine start at the call site.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d n = apSumOffset (fun k => f (a + k)) d m n := by
  calc
    apSumFrom f (m * d + a) d n = apSumFrom f (a + m * d) d n := by
      simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
    _ = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Inverse orientation of `apSumFrom_tail_eq_apSumOffset_shift_start_add_left`. -/
lemma apSumOffset_shift_eq_apSumFrom_tail_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (a + k)) d m n = apSumFrom f (m * d + a) d n := by
  calc
    apSumOffset (fun k => f (a + k)) d m n = apSumFrom f (a + m * d) d n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n)).symm
    _ = apSumFrom f (m * d + a) d n := by
      simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]

/-- Affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (a + k)`.

This is the `m = 0` case of `apSumFrom_tail_eq_apSumOffset_shift`.
-/
lemma apSumFrom_eq_apSumOffset_shift (f : ℕ → ℤ) (a d n : ℕ) :
    apSumFrom f a d n = apSumOffset (fun k => f (a + k)) d 0 n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := 0) (n := n))

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is the same normal form as `apSumFrom_tail_eq_apSumOffset_shift`, but the shifted sequence is
written in the translation-friendly `k + a` form.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (k + a)) d m n := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (k + a)) d m n := by
      simpa using apSumOffset_shift_comm (f := f) (a := a) (d := d) (m := m) (n := n)

/-- Convenience wrapper for `apSumFrom_tail_eq_apSumOffset_shift_add` when the affine start is
written using the mul-left convention `a + d*m`.

This avoids a manual `Nat.mul_comm` rewrite when normalizing goals into the canonical
`apSumOffset (fun k => f (k + a)) d m n` form.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_add_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + d * m) d n = apSumOffset (fun k => f (k + a)) d m n := by
  simpa [Nat.mul_comm] using
    (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n))
/-- Split an affine tail sum by length, with the *second* tail expressed as an `apSumOffset`
on the shifted sequence `k ↦ f (a + k)`.

This is a convenience normal form when downstream work wants to use the offset-sum nucleus API
for tail-of-tail bounds/splitting lemmas.
-/
lemma apSumFrom_tail_add_length_eq_add_apSumOffset_shift (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) =
      apSumFrom f (a + m * d) d n1 + apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) =
        apSumFrom f (a + m * d) d n1 + apSumFrom f (a + (m + n1) * d) d n2 := by
          simpa using
            apSumFrom_tail_add_length (f := f) (a := a) (d := d) (m := m) (n1 := n1) (n2 := n2)
    _ = apSumFrom f (a + m * d) d n1 + apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
          have h2 :
              apSumFrom f (a + (m + n1) * d) d n2 = apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m + n1)
                (n := n2))
          simpa [h2]

/-- Translation-friendly variant of `apSumFrom_tail_add_length_eq_add_apSumOffset_shift`, with the
shifted sequence written as `k ↦ f (k + a)`.
-/
lemma apSumFrom_tail_add_length_eq_add_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) =
      apSumFrom f (a + m * d) d n1 + apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) =
        apSumFrom f (a + m * d) d n1 + apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
          simpa using
            apSumFrom_tail_add_length_eq_add_apSumOffset_shift (f := f) (a := a) (d := d) (m := m)
              (n1 := n1) (n2 := n2)
    _ = apSumFrom f (a + m * d) d n1 + apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
          simpa using
            congrArg (fun t => apSumFrom f (a + m * d) d n1 + t)
              (apSumOffset_shift_comm (f := f) (a := a) (d := d) (m := m + n1) (n := n2))

/-- Normal form: split an affine tail sum by length and absorb the offset parameter of the second
block into the translation constant.

Concretely, this rewrites the second block
`apSumOffset (fun k => f (k + a)) d (m + n1) n2` as an `m = 0` offset sum on the further-shifted
sequence `k ↦ f (k + (a + (m + n1)*d))`.
-/
lemma apSumFrom_tail_add_length_eq_add_apSumOffset_shift_add_zero_m (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) =
      apSumFrom f (a + m * d) d n1 +
        apSumOffset (fun k => f (k + (a + (m + n1) * d))) d 0 n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) =
        apSumFrom f (a + m * d) d n1 + apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
          simpa using
            apSumFrom_tail_add_length_eq_add_apSumOffset_shift_add (f := f) (a := a) (d := d)
              (m := m) (n1 := n1) (n2 := n2)
    _ = apSumFrom f (a + m * d) d n1 + apSumOffset (fun k => f (k + (a + (m + n1) * d))) d 0 n2 := by
          simpa using
            congrArg (fun t => apSumFrom f (a + m * d) d n1 + t)
              (apSumOffset_shift_add_eq_apSumOffset_shift_add (f := f) (a := a) (d := d)
                (m := m + n1) (n := n2))

/-- Translation-friendly variant of `apSumFrom_add_length_eq_add_apSumOffset_shift`, with the tail
expressed as an `apSumOffset` on the shifted sequence `k ↦ f (k + a)`.

This is a convenience wrapper around `apSumFrom_add_length` and
`apSumFrom_tail_eq_apSumOffset_shift_add`.
-/
lemma apSumFrom_add_length_eq_add_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSumOffset (fun k => f (k + a)) d m n := by
  calc
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSumFrom f (a + m * d) d n := by
      simpa using apSumFrom_add_length (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumFrom f a d m + apSumOffset (fun k => f (k + a)) d m n := by
      simp [apSumFrom_tail_eq_apSumOffset_shift_add]

/-- Normal form: split an affine AP sum by length and eliminate the offset parameter `m` by
absorbing it into the translation constant.

Concretely, this rewrites the tail
`apSumOffset (fun k => f (k + a)) d m n` as an `m = 0` offset sum on the further-shifted sequence
`k ↦ f (k + (a + m*d))`.
-/
lemma apSumFrom_add_length_eq_add_apSumOffset_shift_add_zero_m (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) =
      apSumFrom f a d m + apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
  calc
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSumOffset (fun k => f (k + a)) d m n := by
      simpa using
        apSumFrom_add_length_eq_add_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
          (n := n)
    _ = apSumFrom f a d m + apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
      simp [apSumOffset_shift_add_eq_apSumOffset_shift_add]

/-- Variant of `apSumFrom_add_length_eq_add_apSumOffset_shift_add_zero_m` with the translation
constant written as `m*d + a`.

This wrapper avoids a commutativity rewrite at the call site.
-/
lemma apSumFrom_add_length_eq_add_apSumOffset_shift_add_zero_m_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) =
      apSumFrom f a d m + apSumOffset (fun k => f (k + (m * d + a))) d 0 n := by
  calc
    apSumFrom f a d (m + n) =
        apSumFrom f a d m + apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
          simpa using
            apSumFrom_add_length_eq_add_apSumOffset_shift_add_zero_m (f := f) (a := a) (d := d)
              (m := m) (n := n)
    _ = apSumFrom f a d m + apSumOffset (fun k => f (k + (m * d + a))) d 0 n := by
          have hfun : (fun k => f (k + (a + m * d))) = (fun k => f (k + (m * d + a))) := by
            funext k
            simp [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
          simpa [hfun]

/-- Variant of `apSumFrom_add_length_eq_add_apSumOffset_shift_add_zero_m` with the translation
constant written as `d*m + a`.

This is convenient when downstream work prefers the `d*m` multiplication-on-the-left convention.
-/
lemma apSumFrom_add_length_eq_add_apSumOffset_shift_add_zero_m_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) =
      apSumFrom f a d m + apSumOffset (fun k => f (k + (d * m + a))) d 0 n := by
  calc
    apSumFrom f a d (m + n) =
        apSumFrom f a d m + apSumOffset (fun k => f (k + (m * d + a))) d 0 n := by
          simpa using
            apSumFrom_add_length_eq_add_apSumOffset_shift_add_zero_m_left (f := f) (a := a)
              (d := d) (m := m) (n := n)
    _ = apSumFrom f a d m + apSumOffset (fun k => f (k + (d * m + a))) d 0 n := by
          have hfun : (fun k => f (k + (m * d + a))) = (fun k => f (k + (d * m + a))) := by
            funext k
            simp [Nat.mul_comm]
          simpa [hfun]

/-- Normal form: split an affine AP sum by length, absorb the tail parameter `m` into the affine
start, and eliminate the now-trivial offset sum (`m = 0`) by rewriting it as a homogeneous AP sum.

Concretely, the tail is expressed as `apSum (fun k => f (k + (a + m*d))) d n`.
-/
lemma apSumFrom_add_length_eq_add_apSum_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) =
      apSumFrom f a d m + apSum (fun k => f (k + (a + m * d))) d n := by
  simpa using
    (apSumFrom_add_length_eq_add_apSumOffset_shift_add_zero_m (f := f) (a := a) (d := d) (m := m)
      (n := n))

/-- Variant of `apSumFrom_add_length_eq_add_apSum_shift_add` with the translation constant written as
`m*d + a`.

This avoids a commutativity rewrite at the call site when downstream goals prefer the `m*d + a`
presentation of the affine start.
-/
lemma apSumFrom_add_length_eq_add_apSum_shift_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) =
      apSumFrom f a d m + apSum (fun k => f (k + (m * d + a))) d n := by
  calc
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSum (fun k => f (k + (a + m * d))) d n := by
      simpa using
        (apSumFrom_add_length_eq_add_apSum_shift_add (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumFrom f a d m + apSum (fun k => f (k + (m * d + a))) d n := by
      have hfun : (fun k => f (k + (a + m * d))) = (fun k => f (k + (m * d + a))) := by
        funext k
        simp [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
      simpa [hfun]

/-- Variant of `apSumFrom_add_length_eq_add_apSum_shift_add` with the translation constant written as
`d*m + a`.

This is convenient when downstream work prefers the `d*m` multiplication-on-the-left convention,
so you can avoid commuting multiplication under binders or inside larger expressions.
-/
lemma apSumFrom_add_length_eq_add_apSum_shift_add_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) =
      apSumFrom f a d m + apSum (fun k => f (k + (d * m + a))) d n := by
  calc
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSum (fun k => f (k + (m * d + a))) d n := by
      simpa using
        (apSumFrom_add_length_eq_add_apSum_shift_add_left (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumFrom f a d m + apSum (fun k => f (k + (d * m + a))) d n := by
      have hfun : (fun k => f (k + (m * d + a))) = (fun k => f (k + (d * m + a))) := by
        funext k
        simp [Nat.mul_comm]
      simpa [hfun]

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (k + a)`, with the
starting point written as `m*d + a`.

This is a convenience wrapper around `apSumFrom_tail_eq_apSumOffset_shift_add` that avoids a manual
commutativity rewrite of the affine start.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d n = apSumOffset (fun k => f (k + a)) d m n := by
  -- Reassociate/commute the affine start into the `a + m*d` normal form.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Head+tail normal form for affine tails, with the tail expressed as an `apSumOffset`
on the shifted sequence `k ↦ f (a + k)`.

This is convenient when you want to increment the tail parameter `m` while keeping the remaining
tail in the offset-sum nucleus API.
-/
lemma apSumFrom_tail_succ_length_eq_add_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) =
      f (a + (m + 1) * d) + apSumOffset (fun k => f (a + k)) d (m + 1) n := by
  calc
    apSumFrom f (a + m * d) d (n + 1) =
        f (a + (m + 1) * d) + apSumFrom f (a + (m + 1) * d) d n := by
          simpa using apSumFrom_tail_succ_length (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = f (a + (m + 1) * d) + apSumOffset (fun k => f (a + k)) d (m + 1) n := by
          simp [apSumFrom_tail_eq_apSumOffset_shift]

/-- Translation-friendly variant of `apSumFrom_tail_succ_length_eq_add_apSumOffset_shift`, where the
head term is written as `(m+1)*d + a` and the shifted sequence is `k ↦ f (k + a)`. -/
lemma apSumFrom_tail_succ_length_eq_add_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) =
      f ((m + 1) * d + a) + apSumOffset (fun k => f (k + a)) d (m + 1) n := by
  calc
    apSumFrom f (a + m * d) d (n + 1) =
        f ((m + 1) * d + a) + apSumFrom f ((m + 1) * d + a) d n := by
          simpa using
            apSumFrom_tail_succ_length_add_left (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = f ((m + 1) * d + a) + apSumOffset (fun k => f (k + a)) d (m + 1) n := by
          simp [apSumFrom_tail_eq_apSumOffset_shift_add_left]

/-- Convenience wrapper around `apSumFrom_tail_succ_length_eq_add_apSumOffset_shift_add` with the
affine start written as `m*d + a`.

This avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_tail_succ_length_eq_add_apSumOffset_shift_add_start_add_left (f : ℕ → ℤ)
    (a d m n : ℕ) :
    apSumFrom f (m * d + a) d (n + 1) =
      f ((m + 1) * d + a) + apSumOffset (fun k => f (k + a)) d (m + 1) n := by
  -- Normalize the affine start into the `a + m*d` form and apply the existing lemma.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_succ_length_eq_add_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
      (n := n))

/-- Tail affine AP sum as a homogeneous AP sum on the further-shifted sequence `k ↦ f (k + (m*d + a))`,
with the starting point written as `m*d + a`.

This is a convenience wrapper around `apSumFrom_tail_eq_apSumOffset_shift_add_left` followed by
`apSumOffset_eq_apSum_shift_add`.
-/
lemma apSumFrom_tail_eq_apSum_shift_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d n = apSum (fun k => f (k + (m * d + a))) d n := by
  calc
    apSumFrom f (m * d + a) d n = apSumOffset (fun k => f (k + a)) d m n := by
      simpa using
        apSumFrom_tail_eq_apSumOffset_shift_add_left (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSum (fun k => f (k + (m * d + a))) d n := by
      -- Compose with the shifted-sequence view of `apSumOffset`.
      simpa [Nat.add_assoc] using
        (apSumOffset_eq_apSum_shift_add (f := fun k => f (k + a)) (d := d) (m := m) (n := n))

/-- Mul-left convenience wrapper for `apSumFrom_tail_eq_apSum_shift_add_left`.

This avoids rewriting `m * d` into `d * m` at the call site when your goal uses the
`d * m + a` presentation of the affine start.
-/
lemma apSumFrom_tail_eq_apSum_shift_add_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (d * m + a) d n = apSum (fun k => f (k + (d * m + a))) d n := by
  simpa [Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc,
    Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_eq_apSum_shift_add_left (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Normal form: eliminate the tail parameter `m` by absorbing it into a translation constant.

Concretely, the affine tail sum `apSumFrom f (a + m*d) d n` can be rewritten as an offset sum
with `m = 0` on the further-shifted sequence `k ↦ f (k + (a + m*d))`.

This is a convenience wrapper around `apSumFrom_tail_eq_apSumOffset_shift_add` and
`apSumOffset_shift_add_eq_apSumOffset_shift_add`.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_add_zero_m (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (k + a)) d m n := by
      simpa using
        apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
      simpa using
        apSumOffset_shift_add_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)

/-- Variant of `apSumFrom_tail_eq_apSumOffset_shift_add_zero_m` with the translation constant written
as `m*d + a`.

This wrapper avoids a commutativity rewrite at the call site.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_add_zero_m_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d n = apSumOffset (fun k => f (k + (m * d + a))) d 0 n := by
  calc
    apSumFrom f (m * d + a) d n = apSumOffset (fun k => f (k + a)) d m n := by
      simpa using
        apSumFrom_tail_eq_apSumOffset_shift_add_left (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
      simpa using
        apSumOffset_shift_add_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumOffset (fun k => f (k + (m * d + a))) d 0 n := by
      have hfun : (fun k => f (k + (a + m * d))) = (fun k => f (k + (m * d + a))) := by
        funext k
        simp [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
      simpa [hfun]

/-- Normal form: rewrite an affine tail sum as a homogeneous AP sum on a further-shifted sequence.

Concretely:
`apSumFrom f (a + m*d) d n = apSum (fun k => f (k + (a + m*d))) d n`.

This is `apSumFrom_tail_eq_apSumOffset_shift_add_zero_m` followed by `apSumOffset_zero_m`.
-/
lemma apSumFrom_tail_eq_apSum_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSum (fun k => f (k + (a + m * d))) d n := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
      simpa using
        apSumFrom_tail_eq_apSumOffset_shift_add_zero_m (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSum (fun k => f (k + (a + m * d))) d n := by
      simpa using
        (apSumOffset_zero_m (f := fun k => f (k + (a + m * d))) (d := d) (n := n))

/-- Inverse orientation of `apSumFrom_tail_eq_apSum_shift_add`. -/
lemma apSum_shift_add_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    apSum (fun k => f (k + (a + m * d))) d n = apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_apSum_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Normal form: eliminate the offset parameter `m` in the canonical affine difference
`apSumFrom f a d (m+n) - apSumFrom f a d m` by absorbing it into a translation constant.

This produces an `apSumOffset` tail with `m = 0` on the further-shifted sequence
`k ↦ f (k + (a + m*d))`.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift_add_zero_m (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (a + m * d) d n := by
      simpa using
        apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumOffset (fun k => f (k + a)) d m n := by
      simpa using
        apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
      simpa using
        apSumOffset_shift_add_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)

/-- Variant of `apSumFrom_sub_eq_apSumOffset_shift_add_zero_m` with the translation constant written
as `m*d + a`.

This wrapper avoids a commutativity rewrite at the call site.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift_add_zero_m_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      apSumOffset (fun k => f (k + (m * d + a))) d 0 n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (a + m * d) d n := by
      simpa using
        apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumFrom f (m * d + a) d n := by
      simp [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
    _ = apSumOffset (fun k => f (k + (m * d + a))) d 0 n := by
      simpa using
        apSumFrom_tail_eq_apSumOffset_shift_add_zero_m_left (f := f) (a := a) (d := d) (m := m)
          (n := n)

/-- Normal form: rewrite the canonical affine difference `(m+n) - m` as a homogeneous AP sum on the
further-shifted sequence `k ↦ f (k + (a + m*d))`.

This is `apSumFrom_sub_eq_apSumOffset_shift_add_zero_m` followed by `apSumOffset_zero_m`.
-/
lemma apSumFrom_sub_eq_apSum_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSum (fun k => f (k + (a + m * d))) d n := by
  simpa using
    (apSumFrom_sub_eq_apSumOffset_shift_add_zero_m (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Variant of `apSumFrom_sub_eq_apSum_shift_add` with the translation constant written as `m*d + a`.

This wrapper avoids a commutativity rewrite at the call site.
-/
lemma apSumFrom_sub_eq_apSum_shift_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSum (fun k => f (k + (m * d + a))) d n := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_eq_apSum_shift_add (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Variant of `apSumFrom_sub_eq_apSum_shift_add` with the translation constant written as `d*m + a`.

This wrapper avoids a commutativity rewrite at the call site when working in a mul-left convention.
-/
lemma apSumFrom_sub_eq_apSum_shift_add_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSum (fun k => f (k + (d * m + a))) d n := by
  simpa [Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_eq_apSum_shift_add_left (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Translation-friendly step-one normal form: rewrite the canonical affine difference `(m+n) - m`
as a step-one homogeneous AP sum with summand `k*d + (a + m*d)`.

This is `apSumFrom_sub_eq_apSumFrom_tail` followed by `apSumFrom_tail_eq_apSum_step_one_add_left`.
-/
lemma apSumFrom_sub_eq_apSum_step_one_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      apSum (fun k => f (k * d + (a + m * d))) 1 n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (a + m * d) d n := by
      simpa using
        apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSum (fun k => f (k * d + (a + m * d))) 1 n := by
      simpa using
        apSumFrom_tail_eq_apSum_step_one_add_left (f := f) (a := a) (d := d) (m := m) (n := n)

/-- Variant of `apSumFrom_sub_eq_apSum_step_one_add_left` with the affine tail start written as
`m*d + a`.

This wrapper avoids a commutativity rewrite at the call site.
-/
lemma apSumFrom_sub_eq_apSum_step_one_add_left_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      apSum (fun k => f (k * d + (m * d + a))) 1 n := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_eq_apSum_step_one_add_left (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Variant of `apSumFrom_sub_eq_apSum_step_one_add_left` with the affine tail start written as
`d*m + a`.

This wrapper avoids a commutativity rewrite at the call site when working in a mul-left convention.
-/
lemma apSumFrom_sub_eq_apSum_step_one_add_left_start_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      apSum (fun k => f (k * d + (d * m + a))) 1 n := by
  simpa [Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_eq_apSum_step_one_add_left_start_add_left (f := f) (a := a) (d := d) (m := m)
      (n := n))

/-- Translation-friendly tail step-one normal form with the affine start written as `m*d + a`.

This is the `m*d + a` wrapper of `apSumFrom_tail_eq_apSum_step_one_add_left`, and avoids a
commutativity rewrite at the call site.
-/
lemma apSumFrom_tail_eq_apSum_step_one_add_left_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d n = apSum (fun k => f (k * d + (m * d + a))) 1 n := by
  -- Normalize the affine start from `m*d + a` to `a + m*d` and apply the canonical lemma.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_eq_apSum_step_one_add_left (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Translation-friendly tail step-one normal form with the affine start written as `d*m + a`.

This is the mul-left wrapper of `apSumFrom_tail_eq_apSum_step_one_add_left_start_add_left`, and
avoids a commutativity rewrite at the call site.
-/
lemma apSumFrom_tail_eq_apSum_step_one_add_left_start_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (d * m + a) d n = apSum (fun k => f (k * d + (d * m + a))) 1 n := by
  simpa [Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_eq_apSum_step_one_add_left_start_add_left (f := f) (a := a) (d := d) (m := m)
      (n := n))

/-- Translation-friendly tail step-one normal form, but expressed as an `apSumOffset` with `m = 0`,
with the affine start written as `m*d + a`.

This is the `m*d + a` wrapper of `apSumFrom_tail_eq_apSumOffset_step_one_zero_m_add_left`.
-/
lemma apSumFrom_tail_eq_apSumOffset_step_one_zero_m_add_left_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d n =
      apSumOffset (fun k => f (k * d + (m * d + a))) 1 0 n := by
  -- Normalize the affine start from `m*d + a` to `a + m*d` and apply the canonical lemma.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_eq_apSumOffset_step_one_zero_m_add_left (f := f) (a := a) (d := d) (m := m)
      (n := n))

/-- Inverse orientation of `apSumFrom_tail_eq_apSumOffset_shift`.

This is useful when you have already normalized into the shifted-sequence form
`apSumOffset (fun k => f (a + k)) …` but want to return to the affine nucleus API.
-/
lemma apSumOffset_shift_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (a + k)) d m n = apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Inverse orientation of `apSumFrom_tail_eq_apSumOffset_shift_add`.

This is useful when you have already normalized into the translation-friendly shifted-sequence
form `apSumOffset (fun k => f (k + a)) …` but want to return to the affine nucleus API.
-/
lemma apSumOffset_shift_add_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n = apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Variant of `apSumOffset_shift_add_eq_apSumFrom_tail` with the affine start written as `m*d + a`.

This wrapper avoids a commutativity rewrite at the call site.
-/
lemma apSumOffset_shift_add_eq_apSumFrom_tail_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n = apSumFrom f (m * d + a) d n := by
  -- Normalize the affine start from `a + m*d` to `m*d + a`.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumOffset_shift_add_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is the `m = 0` case of `apSumFrom_tail_eq_apSumOffset_shift_add`.
-/
lemma apSumFrom_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d n : ℕ) :
    apSumFrom f a d n = apSumOffset (fun k => f (k + a)) d 0 n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := 0) (n := n))

/-- Inverse orientation of `apSumFrom_eq_apSumOffset_shift_add`.

This is the `m = 0` case of `apSumOffset_shift_add_eq_apSumFrom_tail`.
-/
lemma apSumOffset_shift_add_eq_apSumFrom (f : ℕ → ℤ) (a d n : ℕ) :
    apSumOffset (fun k => f (k + a)) d 0 n = apSumFrom f a d n := by
  simpa using (apSumFrom_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (n := n)).symm

/-- Normal form: rewrite the canonical affine difference `(m+n) - m` as an offset AP sum on the
shifted sequence `k ↦ f (k + a)`.

This is the same normal form as `apSumFrom_sub_eq_apSumOffset_shift`, but in the translation-
friendly `k + a` form.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumOffset (fun k => f (k + a)) d m n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (k + a)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
                (n := n))

/-- Inverse orientation of `apSumFrom_sub_eq_apSumOffset_shift_add`.

This is a convenience normal form: if you already have an `apSumOffset` tail sum on the
translation-friendly shifted sequence `k ↦ f (k + a)`, you can rewrite it back into a
difference of affine partial sums.
-/
lemma apSumOffset_shift_add_eq_apSumFrom_sub (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n = apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Tail-of-tail normal form, expressed as an offset AP sum on the shifted sequence `k ↦ f (a + k)`.

This is the `apSumFrom` analogue of `apSumOffset_sub_eq_apSumOffset_tail`.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1
        = apSumFrom f (a + (m + n1) * d) d n2 := by
            simpa using
              (apSumFrom_tail_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m)
                (n1 := n1) (n2 := n2))
    _ = apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m + n1)
                (n := n2))

/-- Tail-of-tail normal form, expressed as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is the translation-friendly `k + a` variant of `apSumFrom_tail_sub_eq_apSumOffset_shift_tail`.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_add_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
        apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
          simpa using
            (apSumFrom_tail_sub_eq_apSumOffset_shift_tail (f := f) (a := a) (d := d) (m := m)
              (n1 := n1) (n2 := n2))
    _ = apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
          simpa using
            apSumOffset_shift_comm (f := f) (a := a) (d := d) (m := m + n1) (n := n2)

/-- Tail-of-tail normal form in the translation-friendly shifted-sequence form, with the affine
start written as `m*d + a`.

This wrapper avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_add_tail_start_add_left (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (m * d + a) d (n1 + n2) - apSumFrom f (m * d + a) d n1 =
      apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_sub_eq_apSumOffset_shift_add_tail (f := f) (a := a) (d := d) (m := m)
      (n1 := n1) (n2 := n2))

/-- Normal form: eliminate the explicit offset parameter in a tail-of-tail affine difference.

Concretely, the tail difference

`apSumFrom f (a + m*d) d (n1+n2) - apSumFrom f (a + m*d) d n1`

can be rewritten as an `apSumOffset` tail with `m = 0` on the further-shifted sequence
`k ↦ f (k + (a + (m+n1)*d))`.

This is `apSumFrom_tail_sub_eq_apSumOffset_shift_add_tail` followed by
`apSumOffset_shift_add_eq_apSumOffset_shift_add` (absorbing the offset into the translation).
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_add_zero_m_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumOffset (fun k => f (k + (a + (m + n1) * d))) d 0 n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
        apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
          simpa using
            (apSumFrom_tail_sub_eq_apSumOffset_shift_add_tail (f := f) (a := a) (d := d) (m := m)
              (n1 := n1) (n2 := n2))
    _ = apSumOffset (fun k => f (k + (a + (m + n1) * d))) d 0 n2 := by
          simpa using
            (apSumOffset_shift_add_eq_apSumOffset_shift_add (f := f) (a := a) (d := d)
              (m := m + n1) (n := n2))

/-- Convenience wrapper around `apSumFrom_tail_sub_eq_apSumOffset_shift_add_zero_m_tail` with the
affine start written as `m*d + a`.

This avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_add_zero_m_tail_start_add_left (f : ℕ → ℤ)
    (a d m n1 n2 : ℕ) :
    apSumFrom f (m * d + a) d (n1 + n2) - apSumFrom f (m * d + a) d n1 =
      apSumOffset (fun k => f (k + ((m + n1) * d + a))) d 0 n2 := by
  have hfun : (fun k => f (k + (a + (m + n1) * d))) = (fun k => f (k + ((m + n1) * d + a))) := by
    funext k
    simp [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm, hfun] using
    (apSumFrom_tail_sub_eq_apSumOffset_shift_add_zero_m_tail (f := f) (a := a) (d := d) (m := m)
      (n1 := n1) (n2 := n2))

/-- Normal form: eliminate the explicit offset parameter in a tail-of-tail affine difference,
and then eliminate the now-trivial offset sum (`m = 0`) into a homogeneous AP sum.

Concretely:

`apSumFrom f (a + m*d) d (n1+n2) - apSumFrom f (a + m*d) d n1`

can be rewritten as

`apSum (fun k => f (k + (a + (m+n1)*d))) d n2`.
-/
lemma apSumFrom_tail_sub_eq_apSum_shift_add_zero_m_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSum (fun k => f (k + (a + (m + n1) * d))) d n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
        apSumOffset (fun k => f (k + (a + (m + n1) * d))) d 0 n2 := by
          simpa using
            (apSumFrom_tail_sub_eq_apSumOffset_shift_add_zero_m_tail (f := f) (a := a) (d := d)
              (m := m) (n1 := n1) (n2 := n2))
    _ = apSum (fun k => f (k + (a + (m + n1) * d))) d n2 := by
          simpa using
            (apSumOffset_zero_m (f := fun k => f (k + (a + (m + n1) * d))) (d := d) (n := n2))

/-- Convenience wrapper around `apSumFrom_tail_sub_eq_apSum_shift_add_zero_m_tail` with the affine
start written as `m*d + a`.

This avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_tail_sub_eq_apSum_shift_add_zero_m_tail_start_add_left (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (m * d + a) d (n1 + n2) - apSumFrom f (m * d + a) d n1 =
      apSum (fun k => f (k + ((m + n1) * d + a))) d n2 := by
  calc
    apSumFrom f (m * d + a) d (n1 + n2) - apSumFrom f (m * d + a) d n1 =
        apSumOffset (fun k => f (k + ((m + n1) * d + a))) d 0 n2 := by
          simpa using
            (apSumFrom_tail_sub_eq_apSumOffset_shift_add_zero_m_tail_start_add_left (f := f)
              (a := a) (d := d) (m := m) (n1 := n1) (n2 := n2))
    _ = apSum (fun k => f (k + ((m + n1) * d + a))) d n2 := by
          simpa using
            (apSumOffset_zero_m (f := fun k => f (k + ((m + n1) * d + a))) (d := d) (n := n2))

/-- Normal form: rewrite the canonical affine difference `(m+n) - m` as an offset AP sum on the
shifted sequence `k ↦ f (a + k)`.

This is the `apSumFrom` analogue of `apSum_sub_eq_apSumOffset`, oriented so that rewriting turns a
subtraction into an explicit `apSumOffset` tail.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Inverse orientation of `apSumFrom_sub_eq_apSumOffset_shift`.

This is a convenience normal form: if you already have an `apSumOffset` tail sum on the shifted
sequence `k ↦ f (a + k)`, you can rewrite it back into a difference of affine partial sums.
-/
lemma apSumOffset_shift_eq_apSumFrom_sub (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (a + k)) d m n = apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Rewrite the affine tail sum `apSumFrom f (a + m*d) d n` as the “paper notation” interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)`.

This is intended for surface statements: keep the nucleus API in terms of `apSumFrom` and use
this lemma only when matching paper notation.
-/
lemma apSumFrom_tail_eq_sum_Icc (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
      simpa using
        (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- Translation-friendly variant of `apSumFrom_tail_eq_sum_Icc`, with the summand written as
`f (i*d + a)` instead of `f (a + i*d)`.

This is useful when `simp`-normal forms or rewriting lemmas prefer `i*d + a`.
-/
lemma apSumFrom_tail_eq_sum_Icc_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) := by
  -- Start from the `a + i*d` version and normalize the summand.
  have h := apSumFrom_tail_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)
  -- `simp` can rewrite under the binder once we identify the two summand functions.
  have hsummand : (fun i => f (a + i * d)) = (fun i => f (i * d + a)) := by
    funext i
    simpa [Nat.add_comm] using congrArg f (Nat.add_comm a (i * d))
  simpa [hsummand] using h

/-- Mul-left variant of `apSumFrom_tail_eq_sum_Icc`, with the step written as `d * i`.

This avoids commuting multiplication under binders when your surface statement prefers the paper
shape `a + d*i`.
-/
lemma apSumFrom_tail_eq_sum_Icc_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + d * i)) := by
  have h := apSumFrom_tail_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)
  have hsummand : (fun i => f (a + i * d)) = (fun i => f (a + d * i)) := by
    funext i
    simpa [Nat.mul_comm] using congrArg (fun t => f (a + t)) (Nat.mul_comm i d)
  simpa [hsummand] using h

/-- Mul-left + translation-friendly variant of `apSumFrom_tail_eq_sum_Icc_add`, with the summand
written as `f (d*i + a)`.

This matches the “mul-left” paper normal form while also keeping the additive shift on the right.
-/
lemma apSumFrom_tail_eq_sum_Icc_mul_left_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (d * i + a)) := by
  have h := apSumFrom_tail_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n)
  have hsummand : (fun i => f (i * d + a)) = (fun i => f (d * i + a)) := by
    funext i
    simpa [Nat.mul_comm] using congrArg (fun t => f (t + a)) (Nat.mul_comm i d)
  simpa [hsummand] using h

/-- Normal form: rewrite the “paper notation” interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)` back to the affine tail sum `apSumFrom f (a + m*d) d n`.

This is useful when normalizing a surface statement into the nucleus API.
-/
lemma sum_Icc_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Mul-left variant of `sum_Icc_eq_apSumFrom_tail`, with the summand written as `f (a + d*i)`.

This is the inverse orientation of `apSumFrom_tail_eq_sum_Icc_mul_left`.
-/
lemma sum_Icc_eq_apSumFrom_tail_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + d * i)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc_mul_left (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Translation-friendly variant of `sum_Icc_eq_apSumFrom_tail`, with the summand written as
`f (i*d + a)` instead of `f (a + i*d)`.

This is the inverse orientation of `apSumFrom_tail_eq_sum_Icc_add`.
-/
lemma sum_Icc_eq_apSumFrom_tail_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Mul-left + translation-friendly variant of `sum_Icc_eq_apSumFrom_tail_add`, with the summand
written as `f (d*i + a)`.

This is the inverse orientation of `apSumFrom_tail_eq_sum_Icc_mul_left_add`.
-/
lemma sum_Icc_eq_apSumFrom_tail_mul_left_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (d * i + a)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc_mul_left_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Rewrite an affine tail sum as a length-indexed interval sum over `Icc 1 n`.

Concretely, this is the normal form
`∑ i ∈ Icc 1 n, f (a + (m+i)*d)`.

This is sometimes convenient when you want a *fixed* lower endpoint (1) and you prefer to keep the
tail bookkeeping inside the summand, analogous to `apSumOffset_eq_sum_Icc_length`.
-/
lemma apSumFrom_tail_eq_sum_Icc_length (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc 1 n).sum (fun i => f (a + (m + i) * d)) := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc 1 n).sum (fun i => f (a + (m + i) * d)) := by
      simpa using
        (apSumOffset_eq_sum_Icc_length (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- Translation-friendly variant of `apSumFrom_tail_eq_sum_Icc_length`, with the summand written as
`f ((m+i)*d + a)` instead of `f (a + (m+i)*d)`. -/
lemma apSumFrom_tail_eq_sum_Icc_length_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc 1 n).sum (fun i => f ((m + i) * d + a)) := by
  have h := apSumFrom_tail_eq_sum_Icc_length (f := f) (a := a) (d := d) (m := m) (n := n)
  have hsummand : (fun i => f (a + (m + i) * d)) = (fun i => f ((m + i) * d + a)) := by
    funext i
    have hcomm : a + (m + i) * d = (m + i) * d + a := by
      simpa using Nat.add_comm a ((m + i) * d)
    simpa [hcomm] using congrArg f hcomm
  simpa [hsummand] using h

/-- Inverse orientation of `apSumFrom_tail_eq_sum_Icc_length`. -/
lemma sum_Icc_length_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc 1 n).sum (fun i => f (a + (m + i) * d)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc_length (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Inverse orientation of `apSumFrom_tail_eq_sum_Icc_length_add`. -/
lemma sum_Icc_length_eq_apSumFrom_tail_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc 1 n).sum (fun i => f ((m + i) * d + a)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc_length_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Mul-left variant of `apSumFrom_tail_eq_sum_Icc_length`, with the summand written as
`f (a + d * (m+i))` instead of `f (a + (m+i) * d)`.

This avoids commuting multiplication under binders when you are working in a `d * i` convention.
-/
lemma apSumFrom_tail_eq_sum_Icc_length_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc 1 n).sum (fun i => f (a + d * (m + i))) := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc 1 n).sum (fun i => f (a + d * (m + i))) := by
      simpa using
        (apSumOffset_eq_sum_Icc_length_mul_left (f := fun k => f (a + k)) (d := d) (m := m)
          (n := n))

/-- Mul-left + translation-friendly variant of `apSumFrom_tail_eq_sum_Icc_length_mul_left`,
with the summand written as `f (d * (m+i) + a)`.
-/
lemma apSumFrom_tail_eq_sum_Icc_length_mul_left_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc 1 n).sum (fun i => f (d * (m + i) + a)) := by
  have h := apSumFrom_tail_eq_sum_Icc_length_mul_left (f := f) (a := a) (d := d) (m := m) (n := n)
  have hsummand : (fun i => f (a + d * (m + i))) = (fun i => f (d * (m + i) + a)) := by
    funext i
    have hcomm : a + d * (m + i) = d * (m + i) + a := by
      simpa using Nat.add_comm a (d * (m + i))
    simpa [hcomm] using congrArg f hcomm
  simpa [hsummand] using h

/-- Inverse orientation of `apSumFrom_tail_eq_sum_Icc_length_mul_left`. -/
lemma sum_Icc_length_eq_apSumFrom_tail_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc 1 n).sum (fun i => f (a + d * (m + i))) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc_length_mul_left (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Inverse orientation of `apSumFrom_tail_eq_sum_Icc_length_mul_left_add`. -/
lemma sum_Icc_length_eq_apSumFrom_tail_mul_left_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc 1 n).sum (fun i => f (d * (m + i) + a)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc_length_mul_left_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Normal form (paper → nucleus, tail, translation-friendly): when `m ≤ n`, rewrite the interval sum
`∑ i ∈ Icc (m+1) n, f (i*d + a)` to the affine tail sum `apSumFrom f (a + m*d) d (n - m)`.

This is the `i*d + a` analogue of `sum_Icc_eq_apSumFrom_tail_of_le`.
-/
lemma sum_Icc_eq_apSumFrom_tail_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) =
      apSumFrom f (a + m * d) d (n - m) := by
  -- Put the interval endpoint into the canonical `(m + (n - m))` form and use the fixed-length lemma.
  simpa [Nat.add_sub_of_le hmn] using
    (sum_Icc_eq_apSumFrom_tail_add (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Mul-left variant of `sum_Icc_eq_apSumFrom_tail_of_le`, with the summand written as
`f (a + d*i)`.

This avoids commuting multiplication under binders when working in a `d * i` convention.
-/
lemma sum_Icc_eq_apSumFrom_tail_of_le_mul_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + d * i)) =
      apSumFrom f (a + m * d) d (n - m) := by
  -- Convert to the fixed-length `(m + (n - m))` form, then use the fixed-length mul-left lemma.
  simpa [Nat.add_sub_of_le hmn] using
    (sum_Icc_eq_apSumFrom_tail_mul_left (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Mul-left + translation-friendly variant of `sum_Icc_eq_apSumFrom_tail_of_le_add`, with the
summand written as `f (d*i + a)`.

This avoids commuting multiplication under binders when working in a `d * i` convention.
-/
lemma sum_Icc_eq_apSumFrom_tail_of_le_mul_left_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (d * i + a)) =
      apSumFrom f (a + m * d) d (n - m) := by
  -- Convert to the fixed-length `(m + (n - m))` form, then use the fixed-length mul-left lemma.
  simpa [Nat.add_sub_of_le hmn] using
    (sum_Icc_eq_apSumFrom_tail_mul_left_add (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Normal form (paper → nucleus, tail, glue, fixed-length): rewrite the affine interval sum
`∑ i ∈ Icc (m+1) (m+n), f (i*d + a)` directly as an offset AP sum on the shifted sequence
`k ↦ f (k + a)`.

This is a convenience wrapper: it combines `sum_Icc_eq_apSumFrom_tail_add` with
`apSumFrom_tail_eq_apSumOffset_shift_add`.
-/
lemma sum_Icc_eq_apSumOffset_shift_add_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) =
      apSumOffset (fun k => f (k + a)) d m n := by
  calc
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) =
        apSumFrom f (a + m * d) d n := by
          simpa using
            (sum_Icc_eq_apSumFrom_tail_add (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (k + a)) d m n := by
          simpa using
            (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Mul-left + translation-friendly variant of `sum_Icc_eq_apSumOffset_shift_add_add`.

This avoids commuting multiplication under binders when working in a `d * i` convention.
-/
lemma sum_Icc_eq_apSumOffset_shift_add_mul_left_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (d * i + a)) =
      apSumOffset (fun k => f (k + a)) d m n := by
  calc
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (d * i + a)) =
        apSumFrom f (a + m * d) d n := by
          simpa using
            (sum_Icc_eq_apSumFrom_tail_mul_left_add (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (k + a)) d m n := by
          simpa using
            (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Normal form (nucleus → paper, tail, glue, fixed-length): rewrite an offset AP sum on the shifted
sequence `k ↦ f (k + a)` as an affine interval sum with the summand written as `f (i*d + a)`.

This is the inverse orientation companion to `sum_Icc_eq_apSumOffset_shift_add_add`.
-/
lemma apSumOffset_shift_add_eq_sum_Icc_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) := by
  calc
    apSumOffset (fun k => f (k + a)) d m n = apSumFrom f (a + m * d) d n := by
      simpa using
        (apSumOffset_shift_add_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) := by
      simpa using
        (apSumFrom_tail_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Mul-left + translation-friendly variant of `apSumOffset_shift_add_eq_sum_Icc_add`.

This avoids commuting multiplication under binders when working in a `d * i` convention.
-/
lemma apSumOffset_shift_add_eq_sum_Icc_mul_left_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (d * i + a)) := by
  calc
    apSumOffset (fun k => f (k + a)) d m n = apSumFrom f (a + m * d) d n := by
      simpa using
        (apSumOffset_shift_add_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (d * i + a)) := by
      simpa using
        (apSumFrom_tail_eq_sum_Icc_mul_left_add (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Normal form (paper → nucleus, tail, glue, fixed-length): rewrite the affine interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)` directly as an offset AP sum on the shifted sequence
`k ↦ f (a + k)`.

This is a convenience wrapper: it combines `sum_Icc_eq_apSumFrom_tail` with
`apSumFrom_tail_eq_apSumOffset_shift`.

This lemma is the “constant-on-the-left” companion to `sum_Icc_eq_apSumOffset_shift_add_add`.
-/
lemma sum_Icc_eq_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) =
      apSumOffset (fun k => f (a + k)) d m n := by
  calc
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) = apSumFrom f (a + m * d) d n := by
      simpa using (sum_Icc_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Mul-left variant of `sum_Icc_eq_apSumOffset_shift`, with summand written as `f (a + d*i)`.

This avoids commuting multiplication under binders when working in a `d * i` convention.
-/
lemma sum_Icc_eq_apSumOffset_shift_mul_left (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + d * i)) =
      apSumOffset (fun k => f (a + k)) d m n := by
  calc
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + d * i)) = apSumFrom f (a + m * d) d n := by
      simpa using
        (sum_Icc_eq_apSumFrom_tail_mul_left (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Normal form (paper → nucleus, tail, glue): when `m ≤ n`, rewrite the affine interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)` directly as an offset AP sum on the shifted sequence
`k ↦ f (a + k)`.

This is the inequality-endpoint companion to `sum_Icc_eq_apSumOffset_shift`.
-/
lemma sum_Icc_eq_apSumOffset_shift_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) =
      apSumOffset (fun k => f (a + k)) d m (n - m) := by
  -- Convert to the fixed-length `(m + (n - m))` form, then use the fixed-length glue lemma.
  simpa [Nat.add_sub_of_le hmn] using
    (sum_Icc_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Mul-left variant of `sum_Icc_eq_apSumOffset_shift_of_le`, with summand written as `f (a + d*i)`.

This avoids commuting multiplication under binders when working in a `d * i` convention.
-/
lemma sum_Icc_eq_apSumOffset_shift_of_le_mul_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + d * i)) =
      apSumOffset (fun k => f (a + k)) d m (n - m) := by
  -- Convert to the fixed-length `(m + (n - m))` form, then use the fixed-length glue lemma.
  simpa [Nat.add_sub_of_le hmn] using
    (sum_Icc_eq_apSumOffset_shift_mul_left (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Normal form (paper → nucleus, tail, glue): when `m ≤ n`, rewrite the affine interval sum
`∑ i ∈ Icc (m+1) n, f (i*d + a)` directly as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is a convenience wrapper: it combines `sum_Icc_eq_apSumFrom_tail_of_le_add` with
`apSumFrom_tail_eq_apSumOffset_shift_add` so downstream work can normalize “paper notation” tails
directly into the `apSumOffset` nucleus API.
-/
lemma sum_Icc_eq_apSumOffset_shift_add_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) =
      apSumOffset (fun k => f (k + a)) d m (n - m) := by
  calc
    (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) =
        apSumFrom f (a + m * d) d (n - m) := by
          simpa using
            (sum_Icc_eq_apSumFrom_tail_of_le_add (f := f) (a := a) (d := d) (m := m) (n := n)
              (hmn := hmn))
    _ = apSumOffset (fun k => f (k + a)) d m (n - m) := by
          simpa using
            (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
              (n := n - m))

/-- Mul-left + translation-friendly variant of `sum_Icc_eq_apSumOffset_shift_add_of_le_add`,
with summand written as `f (d*i + a)`.

This avoids commuting multiplication under binders when working in a `d * i` convention.
-/
lemma sum_Icc_eq_apSumOffset_shift_add_of_le_mul_left_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (d * i + a)) =
      apSumOffset (fun k => f (k + a)) d m (n - m) := by
  calc
    (Finset.Icc (m + 1) n).sum (fun i => f (d * i + a)) =
        apSumFrom f (a + m * d) d (n - m) := by
          simpa using
            (sum_Icc_eq_apSumFrom_tail_of_le_mul_left_add (f := f) (a := a) (d := d) (m := m)
              (n := n) (hmn := hmn))
    _ = apSumOffset (fun k => f (k + a)) d m (n - m) := by
          simpa using
            (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
              (n := n - m))

/-- Normal form (nucleus → paper, tail): when `m ≤ n`, rewrite the offset AP sum on the shifted
sequence `k ↦ f (k + a)` into the affine interval sum `∑ i ∈ Icc (m+1) n, f (i*d + a)`.

This is the inverse orientation of `sum_Icc_eq_apSumOffset_shift_add_of_le_add`.
-/
lemma apSumOffset_shift_add_eq_sum_Icc_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumOffset (fun k => f (k + a)) d m (n - m) =
      (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) := by
  simpa using
    (sum_Icc_eq_apSumOffset_shift_add_of_le_add (f := f) (a := a) (d := d) (m := m) (n := n)
      (hmn := hmn)).symm

/-- Mul-left + translation-friendly variant of `apSumOffset_shift_add_eq_sum_Icc_of_le_add`, with
summand written as `f (d*i + a)`.
-/
lemma apSumOffset_shift_add_eq_sum_Icc_of_le_mul_left_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumOffset (fun k => f (k + a)) d m (n - m) =
      (Finset.Icc (m + 1) n).sum (fun i => f (d * i + a)) := by
  simpa using
    (sum_Icc_eq_apSumOffset_shift_add_of_le_mul_left_add (f := f) (a := a) (d := d) (m := m)
      (n := n) (hmn := hmn)).symm


/-- Split the “paper notation” affine interval sum
`∑ i ∈ Icc (m+1) (m+(n₁+n₂)), f (a + i*d)` into the first `n₁` terms and the next `n₂` terms.

This is the affine counterpart of `Discrepancy.sum_Icc_add_length`.
-/
lemma sum_Icc_add_length_affine (f : ℕ → ℤ) (a d m n₁ n₂ : ℕ) :
    (Finset.Icc (m + 1) (m + (n₁ + n₂))).sum (fun i => f (a + i * d)) =
      (Finset.Icc (m + 1) (m + n₁)).sum (fun i => f (a + i * d)) +
        (Finset.Icc (m + n₁ + 1) (m + n₁ + n₂)).sum (fun i => f (a + i * d)) := by
  -- Reduce to the non-affine splitting lemma by viewing `i ↦ f (a + i*d)` as the summand.
  simpa using
    (MoltResearch.sum_Icc_add_length (f := fun i => f (a + i)) (d := d) (m := m) (n₁ := n₁)
      (n₂ := n₂))

/-- Variant of `sum_Icc_add_length_affine` with the step written as `d * i` (mul-left form).

This matches the “mul-left” paper normal forms (`a + d*i`) and avoids commuting multiplication
under binders.
-/
lemma sum_Icc_add_length_affine_mul_left (f : ℕ → ℤ) (a d m n₁ n₂ : ℕ) :
    (Finset.Icc (m + 1) (m + (n₁ + n₂))).sum (fun i => f (a + d * i)) =
      (Finset.Icc (m + 1) (m + n₁)).sum (fun i => f (a + d * i)) +
        (Finset.Icc (m + n₁ + 1) (m + n₁ + n₂)).sum (fun i => f (a + d * i)) := by
  classical
  simpa [Nat.mul_comm] using
    (sum_Icc_add_length_affine (f := f) (a := a) (d := d) (m := m) (n₁ := n₁) (n₂ := n₂))

/-- Variant of `sum_Icc_add_length_affine_mul_left` with the affine term written as `d*i + a`.

This is convenient when downstream normal forms standardize on the translation-friendly `… + a`
presentation.
-/
lemma sum_Icc_add_length_affine_mul_left_add (f : ℕ → ℤ) (a d m n₁ n₂ : ℕ) :
    (Finset.Icc (m + 1) (m + (n₁ + n₂))).sum (fun i => f (d * i + a)) =
      (Finset.Icc (m + 1) (m + n₁)).sum (fun i => f (d * i + a)) +
        (Finset.Icc (m + n₁ + 1) (m + n₁ + n₂)).sum (fun i => f (d * i + a)) := by
  classical
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (sum_Icc_add_length_affine_mul_left (f := f) (a := a) (d := d) (m := m) (n₁ := n₁)
      (n₂ := n₂))

/-- Translation-friendly variant of `sum_Icc_add_length_affine`, with the summand written as
`f (i*d + a)` instead of `f (a + i*d)`.

This is useful when you want to avoid commuting `a + …` under binders.
-/
lemma sum_Icc_add_length_affine_add (f : ℕ → ℤ) (a d m n₁ n₂ : ℕ) :
    (Finset.Icc (m + 1) (m + (n₁ + n₂))).sum (fun i => f (i * d + a)) =
      (Finset.Icc (m + 1) (m + n₁)).sum (fun i => f (i * d + a)) +
        (Finset.Icc (m + n₁ + 1) (m + n₁ + n₂)).sum (fun i => f (i * d + a)) := by
  have h := sum_Icc_add_length_affine (f := f) (a := a) (d := d) (m := m) (n₁ := n₁) (n₂ := n₂)
  have hsummand : (fun i => f (a + i * d)) = (fun i => f (i * d + a)) := by
    funext i
    simpa [Nat.add_comm] using congrArg f (Nat.add_comm a (i * d))
  simpa [hsummand] using h


/-- Split the affine interval sum `∑ i ∈ Icc (m+1) n, f (a + i*d)` at an intermediate index `k`,
assuming `m ≤ k ≤ n`.

This is a convenience wrapper around `sum_Icc_add_length_affine` that avoids manual arithmetic
when your surface statement uses a variable upper endpoint.
-/
lemma sum_Icc_split_affine_of_le (f : ℕ → ℤ) (a d : ℕ) {m k n : ℕ}
    (hmk : m ≤ k) (hkn : k ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) =
      (Finset.Icc (m + 1) k).sum (fun i => f (a + i * d)) +
        (Finset.Icc (k + 1) n).sum (fun i => f (a + i * d)) := by
  have hupper : m + ((k - m) + (n - k)) = n := by
    calc
      m + ((k - m) + (n - k)) = (m + (k - m)) + (n - k) := by
        simp [Nat.add_assoc]
      _ = k + (n - k) := by
        simp [Nat.add_sub_of_le hmk, Nat.add_assoc]
      _ = n := by
        simp [Nat.add_sub_of_le hkn]
  calc
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d))
        = (Finset.Icc (m + 1) (m + ((k - m) + (n - k)))).sum (fun i => f (a + i * d)) := by
            simpa [hupper]
    _ = (Finset.Icc (m + 1) (m + (k - m))).sum (fun i => f (a + i * d)) +
          (Finset.Icc (m + (k - m) + 1) (m + (k - m) + (n - k))).sum
              (fun i => f (a + i * d)) := by
            simpa using
              (sum_Icc_add_length_affine (f := f) (a := a) (d := d) (m := m)
                (n₁ := k - m) (n₂ := n - k))
    _ = (Finset.Icc (m + 1) k).sum (fun i => f (a + i * d)) +
          (Finset.Icc (k + 1) n).sum (fun i => f (a + i * d)) := by
            -- Normalize endpoints using `m + (k - m) = k` and `k + (n - k) = n`.
            simp [Nat.add_sub_of_le hmk, Nat.add_sub_of_le hkn, Nat.add_assoc, Nat.add_left_comm,
              Nat.add_comm]

/-- Translation-friendly variant of `sum_Icc_split_affine_of_le`, with the summand written as
`f (i*d + a)` instead of `f (a + i*d)`.

This is useful when downstream normal forms are expressed in the `i*d + a` convention.
-/
lemma sum_Icc_split_affine_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m k n : ℕ}
    (hmk : m ≤ k) (hkn : k ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) =
      (Finset.Icc (m + 1) k).sum (fun i => f (i * d + a)) +
        (Finset.Icc (k + 1) n).sum (fun i => f (i * d + a)) := by
  have h := sum_Icc_split_affine_of_le (f := f) (a := a) (d := d) (m := m) (k := k) (n := n)
    (hmk := hmk) (hkn := hkn)
  have hsummand : (fun i => f (a + i * d)) = (fun i => f (i * d + a)) := by
    funext i
    simpa [Nat.add_comm] using congrArg f (Nat.add_comm a (i * d))
  simpa [hsummand] using h


/-- Mul-left variant of `sum_Icc_split_affine_of_le`, with the summand written as `f (a + d*i)`.

This avoids commuting multiplication under binders when downstream normal forms use the `d * i`
convention.
-/
lemma sum_Icc_split_affine_of_le_mul_left (f : ℕ → ℤ) (a d : ℕ) {m k n : ℕ}
    (hmk : m ≤ k) (hkn : k ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + d * i)) =
      (Finset.Icc (m + 1) k).sum (fun i => f (a + d * i)) +
        (Finset.Icc (k + 1) n).sum (fun i => f (a + d * i)) := by
  have h :=
    sum_Icc_split_affine_of_le (f := f) (a := a) (d := d) (m := m) (k := k) (n := n)
      (hmk := hmk) (hkn := hkn)
  have hsummand : (fun i => f (a + i * d)) = (fun i => f (a + d * i)) := by
    funext i
    simpa [Nat.mul_comm] using congrArg (fun t => f (a + t)) (Nat.mul_comm i d)
  simpa [hsummand] using h

/-- Mul-left + translation-friendly variant of `sum_Icc_split_affine_of_le_add`, with the summand
written as `f (d*i + a)`.

This avoids commuting multiplication under binders when downstream normal forms use the `d * i`
convention.
-/
lemma sum_Icc_split_affine_of_le_mul_left_add (f : ℕ → ℤ) (a d : ℕ) {m k n : ℕ}
    (hmk : m ≤ k) (hkn : k ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (d * i + a)) =
      (Finset.Icc (m + 1) k).sum (fun i => f (d * i + a)) +
        (Finset.Icc (k + 1) n).sum (fun i => f (d * i + a)) := by
  have h :=
    sum_Icc_split_affine_of_le_add (f := f) (a := a) (d := d) (m := m) (k := k) (n := n)
      (hmk := hmk) (hkn := hkn)
  have hsummand : (fun i => f (i * d + a)) = (fun i => f (d * i + a)) := by
    funext i
    simpa [Nat.mul_comm] using congrArg (fun t => f (t + a)) (Nat.mul_comm i d)
  simpa [hsummand] using h


/-- Normal form: when `m ≤ n`, rewrite the “paper notation” interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)` to the affine tail sum `apSumFrom f (a + m*d) d (n - m)`.

This is the affine analogue of `sum_Icc_eq_apSumOffset`.
-/
lemma sum_Icc_eq_apSumFrom_tail_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) =
      apSumFrom f (a + m * d) d (n - m) := by
  -- Put the interval endpoint into the canonical `(m + (n - m))` form and use
  -- `sum_Icc_eq_apSumFrom_tail`.
  simpa [Nat.add_sub_of_le hmn] using
    (sum_Icc_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Surface form: when `m ≤ n`, rewrite the affine tail sum `apSumFrom f (a + m*d) d (n - m)` as
an interval sum `∑ i ∈ Icc (m+1) n, f (a + i*d)`.

This is the affine analogue of `apSumOffset_eq_sum_Icc_of_le`.
-/
lemma apSumFrom_tail_eq_sum_Icc_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f (a + m * d) d (n - m) =
      (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Translation-friendly surface form: when `m ≤ n`, rewrite the affine tail sum
`apSumFrom f (a + m*d) d (n - m)` as an interval sum `∑ i ∈ Icc (m+1) n, f (i*d + a)`.

This is the `i*d + a` analogue of `apSumFrom_tail_eq_sum_Icc_of_le`.
-/
lemma apSumFrom_tail_eq_sum_Icc_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f (a + m * d) d (n - m) =
      (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) := by
  -- Convert to the fixed-length `(m + (n - m))` form, then use the fixed-length add-left lemma.
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Mul-left variant of `apSumFrom_tail_eq_sum_Icc_of_le`, with the summand written as `f (a + d*i)`.

This avoids commuting multiplication under binders when working in a `d * i` convention.
-/
lemma apSumFrom_tail_eq_sum_Icc_of_le_mul_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f (a + m * d) d (n - m) =
      (Finset.Icc (m + 1) n).sum (fun i => f (a + d * i)) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sum_Icc_mul_left (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Mul-left + translation-friendly variant of `apSumFrom_tail_eq_sum_Icc_of_le_add`, with the
summand written as `f (d*i + a)`.

This avoids commuting multiplication under binders when working in a `d * i` convention.
-/
lemma apSumFrom_tail_eq_sum_Icc_of_le_mul_left_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f (a + m * d) d (n - m) =
      (Finset.Icc (m + 1) n).sum (fun i => f (d * i + a)) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sum_Icc_mul_left_add (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Difference of two affine AP partial sums as an offset AP sum on the shifted sequence
`k ↦ f (a + k)` when `m ≤ n`.

This is the affine analogue of `apSum_sub_apSum_eq_apSumOffset`.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m)
                (n := n - m))

/-- `_of_le`-named wrapper for `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift`.

This matches the naming convention of the interval-sum normal-form lemmas (e.g.
`sum_Icc_eq_apSumOffset_of_le`).
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m (n - m) := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n)
      (hmn := hmn))

/-- Difference of two affine AP partial sums as an offset AP sum on the shifted sequence
`k ↦ f (k + a)` when `m ≤ n`.

This is the same normal form as `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift`, but in the
translation-friendly `k + a` form.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (k + a)) d m (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m (n - m) := by
      simpa using
        (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumOffset (fun k => f (k + a)) d m (n - m) := by
      simpa using apSumOffset_shift_comm (f := f) (a := a) (d := d) (m := m) (n := n - m)

/-- `_of_le`-named wrapper for `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add`.

This matches the naming convention of the interval-sum normal-form lemmas (e.g.
`sum_Icc_eq_apSumOffset_of_le`).
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (k + a)) d m (n - m) := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)
      (hmn := hmn))

/-- Normal form: eliminate the offset parameter `m` in the affine difference
`apSumFrom f a d n - apSumFrom f a d m` (with `m ≤ n`) by absorbing it into the translation
constant.

This produces an `apSumOffset` tail with `m = 0` on the further-shifted sequence
`k ↦ f (k + (a + m*d))`.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_zero_m_of_le (f : ℕ → ℤ) (a d : ℕ)
    {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      apSumOffset (fun k => f (k + (a + m * d))) d 0 (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (k + a)) d m (n - m) := by
      simpa using
        (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
          (n := n) (hmn := hmn))
    _ = apSumOffset (fun k => f (k + (a + m * d))) d 0 (n - m) := by
      simpa using
        (apSumOffset_shift_add_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
          (n := n - m))

/-- Variant of `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_zero_m_of_le` with the translation
constant written as `m*d + a`.

This wrapper avoids a commutativity rewrite at the call site.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_zero_m_left_of_le (f : ℕ → ℤ) (a d : ℕ)
    {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      apSumOffset (fun k => f (k + (m * d + a))) d 0 (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m = apSumFrom f (a + m * d) d (n - m) := by
      simpa using
        (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (m := m) (n := n)
          (hmn := hmn))
    _ = apSumFrom f (m * d + a) d (n - m) := by
      simp [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
    _ = apSumOffset (fun k => f (k + (m * d + a))) d 0 (n - m) := by
      simpa using
        apSumFrom_tail_eq_apSumOffset_shift_add_zero_m_left (f := f) (a := a) (d := d) (m := m)
          (n := n - m)

/-- Normal form: when `m ≤ n`, rewrite the difference of affine AP partial sums as a homogeneous
AP sum on a further-shifted sequence.

Concretely, this eliminates the offset parameter by absorbing it into the translation constant,
then rewrites the resulting `m = 0` offset sum as a homogeneous `apSum`.

This is the `m ≤ n` analogue of `apSumFrom_sub_eq_apSum_shift_add`.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSum_shift_add_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSum (fun k => f (k + (a + m * d))) d (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m =
        apSumOffset (fun k => f (k + (a + m * d))) d 0 (n - m) := by
          simpa using
            (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_zero_m_of_le (f := f) (a := a)
              (d := d) (m := m) (n := n) (hmn := hmn))
    _ = apSum (fun k => f (k + (a + m * d))) d (n - m) := by
          simpa using
            (apSumOffset_zero_m (f := fun k => f (k + (a + m * d))) (d := d) (n := n - m))

/-- Variant of `apSumFrom_sub_apSumFrom_eq_apSum_shift_add_of_le` with the translation constant
written as `m*d + a`.

This wrapper avoids a commutativity rewrite at the call site.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSum_shift_add_left_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSum (fun k => f (k + (m * d + a))) d (n - m) := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_apSumFrom_eq_apSum_shift_add_of_le (f := f) (a := a) (d := d) (m := m)
      (n := n) (hmn := hmn))

/-- Mul-left + step-one variant of `apSumFrom_sub_apSumFrom_eq_apSum_shift_add_of_le`.

When `m ≤ n`, this rewrites the difference of affine AP partial sums into a step-one homogeneous
AP sum, with the multiplication written as `d * k`.

This avoids commuting multiplication under binders when your downstream statements prefer the
`d * k + const` convention.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSum_step_one_mul_left_add_left_of_le (f : ℕ → ℤ) (a d : ℕ)
    {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      apSum (fun k => f (d * k + (d * m + a))) 1 (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m = apSumFrom f (a + m * d) d (n - m) := by
      simpa using
        (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (m := m) (n := n)
          (hmn := hmn))
    _ = apSum (fun k => f (k * d + (a + m * d))) 1 (n - m) := by
      simpa using
        (apSumFrom_tail_eq_apSum_step_one_add_left (f := f) (a := a) (d := d) (m := m)
          (n := n - m))
    _ = apSum (fun k => f (d * k + (d * m + a))) 1 (n - m) := by
      -- Normalize to the mul-left convention `d*k + (d*m + a)`.
      have hsummand : (fun k => f (k * d + (a + m * d))) = (fun k => f (d * k + (d * m + a))) := by
        funext k
        simp [Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
      simpa [hsummand]

/-- Inverse orientation of `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_zero_m_of_le`. -/
lemma apSumOffset_shift_add_zero_m_eq_apSumFrom_sub_apSumFrom_of_le (f : ℕ → ℤ) (a d : ℕ)
    {m n : ℕ} (hmn : m ≤ n) :
    apSumOffset (fun k => f (k + (a + m * d))) d 0 (n - m) = apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_zero_m_of_le (f := f) (a := a) (d := d)
      (m := m) (n := n) (hmn := hmn)).symm

/-- Inverse orientation of `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift`.

This is a convenience normal form: if you already have an `apSumOffset` tail sum on the shifted
sequence `k ↦ f (a + k)`, you can rewrite it back into a difference of affine partial sums.
-/
lemma apSumOffset_shift_eq_apSumFrom_sub_apSumFrom_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumOffset (fun k => f (a + k)) d m (n - m) = apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n)
      (hmn := hmn)).symm

/-- Inverse orientation of `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add`.

This is a convenience normal form: if you already have an `apSumOffset` tail sum on the
translation-friendly shifted sequence `k ↦ f (k + a)`, you can rewrite it back into a difference
of affine partial sums.
-/
lemma apSumOffset_shift_add_eq_apSumFrom_sub_apSumFrom_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumOffset (fun k => f (k + a)) d m (n - m) = apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
      (n := n) (hmn := hmn)).symm

/-- Rewrite the normal-form difference `apSumFrom f a d (m+n) - apSumFrom f a d m` as an
interval sum `∑ i ∈ Icc (m+1) (m+n), f (a + i*d)`.

This is intended for surface statements: keep the nucleus API in terms of `apSumFrom` and use
this lemma only when matching paper notation.
-/
lemma apSumFrom_sub_eq_sum_Icc (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
            simpa using
              (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- Translation-friendly surface form: rewrite the normal-form difference
`apSumFrom f a d (m+n) - apSumFrom f a d m` as an interval sum with summand written as
`f (d*i + a)`.

This is the multiplication-on-the-left analogue of `apSumFrom_sub_eq_sum_Icc_add`.
-/
lemma apSumFrom_sub_eq_sum_Icc_mul_left_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (d * i + a)) := by
  have hfun : (fun i => f (a + i * d)) = (fun i => f (d * i + a)) := by
    funext i
    calc
      f (a + i * d) = f (i * d + a) := by
        simpa [Nat.add_comm]
      _ = f (d * i + a) := by
        simpa [Nat.mul_comm]
  simpa [hfun] using
    (apSumFrom_sub_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Inverse orientation of `apSumFrom_sub_eq_sum_Icc_mul_left_add`. -/
lemma sum_Icc_eq_apSumFrom_sub_mul_left_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (d * i + a)) =
      apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_eq_sum_Icc_mul_left_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Translation-friendly surface form: rewrite the normal-form difference
`apSumFrom f a d (m+n) - apSumFrom f a d m` as an interval sum with summand written as
`f (i*d + a)`.

This is the `i*d + a` analogue of `apSumFrom_sub_eq_sum_Icc`.
-/
lemma apSumFrom_sub_eq_sum_Icc_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) := by
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_sub_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Inverse orientation of `apSumFrom_sub_eq_sum_Icc_add`. -/
lemma sum_Icc_eq_apSumFrom_sub_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) =
      apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- When `m ≤ n`, rewrite `apSumFrom f a d n - apSumFrom f a d m` as an interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)`.

This is the “paper notation” counterpart of `apSumFrom_sub_apSumFrom_eq_apSumFrom`.
-/
lemma apSumFrom_sub_apSumFrom_eq_sum_Icc (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m)
                (n := n - m))
    _ = (Finset.Icc (m + 1) (m + (n - m))).sum (fun i => f (a + i * d)) := by
            simpa using
              (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n - m))
    _ = (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
            simp [Nat.add_sub_of_le hmn]

/-- Translation-friendly variant of `apSumFrom_sub_apSumFrom_eq_sum_Icc`, with the summand written
as `f (i*d + a)`.

This is useful when rewriting surface goals in a normal form compatible with downstream
translation lemmas.
-/
lemma apSumFrom_sub_apSumFrom_eq_sum_Icc_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = (Finset.Icc (m + 1) (m + (n - m))).sum (fun i => f (i * d + a)) := by
            simpa using
              (apSumFrom_tail_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n - m))
    _ = (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) := by
            simp [Nat.add_sub_of_le hmn]

/-- Mul-left variant of `apSumFrom_sub_apSumFrom_eq_sum_Icc`, with the summand written as
`f (a + d*i)`.

This avoids commuting multiplication under binders when your surface statement uses the paper form
`a + d*i`.
-/
lemma apSumFrom_sub_apSumFrom_eq_sum_Icc_mul_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      (Finset.Icc (m + 1) n).sum (fun i => f (a + d * i)) := by
  have h := apSumFrom_sub_apSumFrom_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n) hmn
  have hsummand : (fun i => f (a + i * d)) = (fun i => f (a + d * i)) := by
    funext i
    simpa [Nat.mul_comm] using congrArg (fun t => f (a + t)) (Nat.mul_comm i d)
  simpa [hsummand] using h

/-- Mul-left variant of `apSumFrom_sub_apSumFrom_eq_sum_Icc_add`, with the summand written as
`f (d*i + a)`.
-/
lemma apSumFrom_sub_apSumFrom_eq_sum_Icc_mul_left_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      (Finset.Icc (m + 1) n).sum (fun i => f (d * i + a)) := by
  have h := apSumFrom_sub_apSumFrom_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n) hmn
  have hsummand : (fun i => f (i * d + a)) = (fun i => f (d * i + a)) := by
    funext i
    simpa [Nat.mul_comm] using congrArg (fun t => f (t + a)) (Nat.mul_comm i d)
  simpa [hsummand] using h

/-- Normal form (paper → nucleus, difference): rewrite the interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)` as the difference of affine AP partial sums.

This is the inverse orientation of `apSumFrom_sub_eq_sum_Icc`.
-/
lemma sum_Icc_eq_apSumFrom_sub (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) =
      apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using (apSumFrom_sub_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Normal form (paper → nucleus, difference): when `m ≤ n`, rewrite the interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)` as a difference of affine AP partial sums.

This is the inverse orientation of `apSumFrom_sub_apSumFrom_eq_sum_Icc`.
-/
lemma sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) =
      apSumFrom f a d n - apSumFrom f a d m := by
  simpa using (apSumFrom_sub_apSumFrom_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)
    hmn).symm

/-- Translation-friendly variant of `sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le`, with the summand
written as `f (i*d + a)`.

This is the inverse orientation of `apSumFrom_sub_apSumFrom_eq_sum_Icc_add`.
-/
lemma sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) =
      apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n) hmn).symm

/-- Mul-left variant of `sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le`, with the summand written as
`f (a + d*i)`.

This is the inverse orientation of `apSumFrom_sub_apSumFrom_eq_sum_Icc_mul_left`.
-/
lemma sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le_mul_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + d * i)) =
      apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_sum_Icc_mul_left (f := f) (a := a) (d := d) (m := m) (n := n)
      hmn).symm

/-- Mul-left + translation-friendly variant of `sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le_add`, with
the summand written as `f (d*i + a)`.

This is the inverse orientation of `apSumFrom_sub_apSumFrom_eq_sum_Icc_mul_left_add`.
-/
lemma sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le_mul_left_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (d * i + a)) =
      apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_sum_Icc_mul_left_add (f := f) (a := a) (d := d) (m := m)
      (n := n) hmn).symm

/-- Sign-sequence bound on `apSumFrom` in the `(m + n) - m` normal form. -/
lemma IsSignSequence.natAbs_apSumFrom_sub_le {f : ℕ → ℤ} (hf : IsSignSequence f)
    (a d m n : ℕ) :
    Int.natAbs (apSumFrom f a d (m + n) - apSumFrom f a d m) ≤ n := by
  have h := IsSignSequence.natAbs_apSumFrom_le (hf := hf) (a := a + m * d) (d := d) (n := n)
  have hEq := apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n)
  simpa [hEq] using h

/-- Split an affine AP partial sum at `m` when `m ≤ n`. -/
lemma apSumFrom_eq_add_apSumFrom_tail (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n = apSumFrom f a d m + apSumFrom f (a + m * d) d (n - m) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_add_length (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Variant of `apSumFrom_eq_add_apSumFrom_tail` with the tail start written as `m*d + a`.

This wrapper avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_eq_add_apSumFrom_tail_start_add_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n = apSumFrom f a d m + apSumFrom f (m * d + a) d (n - m) := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_eq_add_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n) (hmn := hmn))

/-- Split an affine AP partial sum at `m` when `m ≤ n`, with the tail normalized into the
`apSumOffset` API on the shifted sequence `k ↦ f (a + k)`.

This is often the most composable normal form downstream: once the tail is an `apSumOffset`,
bounds/splitting/difference lemmas can be applied without carrying affine start bookkeeping.
-/
lemma apSumFrom_eq_add_apSumOffset_shift (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n =
      apSumFrom f a d m + apSumOffset (fun k => f (a + k)) d m (n - m) := by
  calc
    apSumFrom f a d n
        = apSumFrom f a d m + apSumFrom f (a + m * d) d (n - m) := by
            simpa using (apSumFrom_eq_add_apSumFrom_tail (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumFrom f a d m + apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simp [apSumFrom_tail_eq_apSumOffset_shift]

/-- Split an affine AP partial sum at `m` when `m ≤ n`, with the tail normalized into the
`apSumOffset` API on the translation-friendly shifted sequence `k ↦ f (k + a)`.

This is often the most composable normal form downstream: once the tail is an `apSumOffset`,
bounds/splitting/difference lemmas can be applied without carrying affine start bookkeeping.
-/
lemma apSumFrom_eq_add_apSumOffset_shift_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n =
      apSumFrom f a d m + apSumOffset (fun k => f (k + a)) d m (n - m) := by
  calc
    apSumFrom f a d n
        = apSumFrom f a d m + apSumFrom f (a + m * d) d (n - m) := by
            simpa using (apSumFrom_eq_add_apSumFrom_tail (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumFrom f a d m + apSumOffset (fun k => f (k + a)) d m (n - m) := by
            simp [apSumFrom_tail_eq_apSumOffset_shift_add]

/-- Sign-sequence bound on the difference of two affine AP partial sums when `m ≤ n`. -/
lemma IsSignSequence.natAbs_apSumFrom_sub_apSumFrom_le {f : ℕ → ℤ} (hf : IsSignSequence f)
    (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    Int.natAbs (apSumFrom f a d n - apSumFrom f a d m) ≤ n - m := by
  have h := IsSignSequence.natAbs_apSumFrom_le (hf := hf) (a := a + m * d) (d := d) (n := n - m)
  have hEq := apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn)
  simpa [hEq] using h

end MoltResearch
