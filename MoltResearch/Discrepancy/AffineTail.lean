import MoltResearch.Discrepancy.Affine
import MoltResearch.Discrepancy.Offset

/-!
# Discrepancy: tail/splitting lemmas for `apSumFrom`

(Generated by Forge.)
-/

namespace MoltResearch

/-- Head+tail normal form for affine tails: the first term is `f (a + (m+1)*d)`.

This is the affine-tail analogue of `apSumOffset_succ_length`, convenient when you want to
increment the tail parameter `m` explicitly.
-/
lemma apSumFrom_tail_succ_length (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) =
      f (a + (m + 1) * d) + apSumFrom f (a + (m + 1) * d) d n := by
  -- Start from the generic `apSumFrom_succ_length` and normalize the start point.
  have h := apSumFrom_succ_length (f := f) (a := a + m * d) (d := d) (n := n)
  -- Normalize `(a + m*d) + d` to `a + (m+1)*d`.
  have hstart : (a + m * d) + d = a + (m + 1) * d := by
    calc
      (a + m * d) + d = a + (m * d + d) := by
        simp [Nat.add_assoc]
      _ = a + (m + 1) * d := by
        simpa [Nat.add_assoc, Nat.one_mul] using congrArg (fun t => a + t) (Nat.add_mul m 1 d).symm
  simpa [hstart] using h

/-- Translation-friendly variant of `apSumFrom_tail_succ_length`, with the affine term written as
`(m+1)*d + a`.

This avoids needing `Nat.add_comm` under `simp` goals in downstream proof scripts.
-/
lemma apSumFrom_tail_succ_length_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) =
      f ((m + 1) * d + a) + apSumFrom f ((m + 1) * d + a) d n := by
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_tail_succ_length (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Head+tail normal form for affine tails, with the start written as `m*d + a`.

This is a convenience wrapper around `apSumFrom_tail_succ_length_add_left` that avoids commuting
`a + m*d` at the call site.
-/
lemma apSumFrom_tail_succ_length_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d (n + 1) =
      f ((m + 1) * d + a) + apSumFrom f ((m + 1) * d + a) d n := by
  -- Normalize the affine start into the `a + m*d` form, apply the tail lemma, then normalize back.
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_tail_succ_length_add_left (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Right-end “append one term” normal form for affine tails.

This is the affine-tail analogue of `apSumOffset_succ`: it splits off the *last* term of the tail.
It is convenient when you want to induct on the length `n` while keeping the tail parameter `m`
fixed.
-/
lemma apSumFrom_tail_succ (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) = apSumFrom f (a + m * d) d n + f (a + (m + n + 1) * d) := by
  -- Start from the generic `apSumFrom_succ` and normalize the start point.
  have h := apSumFrom_succ (f := f) (a := a + m * d) (d := d) (n := n)
  -- Normalize `(a + m*d) + (n+1)*d` to `a + (m+n+1)*d`.
  have hlast : (a + m * d) + (n + 1) * d = a + (m + n + 1) * d := by
    calc
      (a + m * d) + (n + 1) * d = a + (m * d + (n + 1) * d) := by
        simp [Nat.add_assoc]
      _ = a + ((m + (n + 1)) * d) := by
        simpa using congrArg (fun t => a + t) (Nat.add_mul m (n + 1) d).symm
      _ = a + (m + n + 1) * d := by
        simp [Nat.add_assoc]
  simpa [hlast, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using h

/-- Translation-friendly variant of `apSumFrom_tail_succ`, with the affine term written as
`(m+n+1)*d + a`.

This is convenient when rewriting goals so that `simp` doesn't need to commute addition inside `f`.
-/
lemma apSumFrom_tail_succ_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d (n + 1) = apSumFrom f (a + m * d) d n + f ((m + n + 1) * d + a) := by
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_tail_succ (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Right-end “append one term” normal form for affine tails, with the start written as `m*d + a`.

This is a convenience wrapper around `apSumFrom_tail_succ_add_left` that avoids commuting
`a + m*d` at the call site.
-/
lemma apSumFrom_tail_succ_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d (n + 1) = apSumFrom f (m * d + a) d n + f ((m + n + 1) * d + a) := by
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_tail_succ_add_left (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Split an affine tail sum by length.

This is the affine-tail analogue of `apSum_add_length`/`apSumOffset_add_length`, expressed with an
explicit tail parameter `m`.
-/
lemma apSumFrom_tail_add_length (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) =
      apSumFrom f (a + m * d) d n1 + apSumFrom f (a + (m + n1) * d) d n2 := by
  have h := apSumFrom_add_length (f := f) (a := a + m * d) (d := d) (m := n1) (n := n2)
  have hstart : (a + m * d) + n1 * d = a + (m + n1) * d := by
    calc
      (a + m * d) + n1 * d = a + (m * d + n1 * d) := by
        simp [Nat.add_assoc]
      _ = a + (m + n1) * d := by
        simpa using congrArg (fun t => a + t) (Nat.add_mul m n1 d).symm
  simpa [hstart] using h

/-- Split an affine tail sum by length, with the affine start written as `m*d + a`.

This wrapper avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_tail_add_length_start_add_left (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (m * d + a) d (n1 + n2) =
      apSumFrom f (m * d + a) d n1 + apSumFrom f ((m + n1) * d + a) d n2 := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_add_length (f := f) (a := a) (d := d) (m := m) (n1 := n1) (n2 := n2))

/-- Difference of two affine AP partial sums as a tail sum when `m ≤ n`. -/
lemma apSumFrom_sub_apSumFrom_eq_apSumFrom (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumFrom f (a + m * d) d (n - m) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sub (f := f) (a := a) (d := d) (m := m) (n := n - m)).symm

/-- Convenience wrapper around `apSumFrom_sub_apSumFrom_eq_apSumFrom` with the tail start written as
`m*d + a`.

This avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumFrom_start_add_left (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumFrom f (m * d + a) d (n - m) := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))

/-- Difference of a longer affine AP partial sum and its initial segment, in the `(m + n) - m`
normal form.

This lemma is a convenience wrapper around `apSumFrom_tail_eq_sub`, oriented so that rewriting
turns a subtraction into an explicit tail sum.
-/
lemma apSumFrom_sub_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (a + m * d) d n := by
  simpa using (apSumFrom_tail_eq_sub (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Convenience wrapper around `apSumFrom_sub_eq_apSumFrom_tail` with the tail start written as
`m*d + a`.

This avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_sub_eq_apSumFrom_tail_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (m * d + a) d n := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Tail-of-tail normal form: subtracting two affine tail sums yields a later tail sum. -/
lemma apSumFrom_tail_sub_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumFrom f (a + (m + n1) * d) d n2 := by
  have h :=
    apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a + m * d) (d := d) (m := n1) (n := n2)
  have hstart : (a + m * d) + n1 * d = a + (m + n1) * d := by
    calc
      (a + m * d) + n1 * d = a + (m * d + n1 * d) := by
        simp [Nat.add_assoc]
      _ = a + (m + n1) * d := by
        simpa using congrArg (fun t => a + t) (Nat.add_mul m n1 d).symm
  simpa [hstart] using h

/-- Tail-of-tail normal form with the affine start written as `m*d + a`.

This is a convenience wrapper around `apSumFrom_tail_sub_eq_apSumFrom_tail` that avoids a manual
commutativity rewrite of the affine start at the call site.
-/
lemma apSumFrom_tail_sub_eq_apSumFrom_tail_start_add_left (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (m * d + a) d (n1 + n2) - apSumFrom f (m * d + a) d n1 =
      apSumFrom f ((m + n1) * d + a) d n2 := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n1 := n1)
      (n2 := n2))

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (a + k)`. -/
lemma apSumFrom_tail_eq_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
  classical
  unfold apSumFrom apSumOffset
  refine Finset.sum_congr rfl ?_
  intro i hi
  have hmul : m * d + (i + 1) * d = (m + i + 1) * d := by
    -- `Nat.add_mul` gives `(m + (i+1)) * d = m*d + (i+1)*d`.
    -- We use it backwards and normalize `m + (i+1)` to `m + i + 1`.
    simpa [Nat.add_assoc] using (Nat.add_mul m (i + 1) d).symm
  calc
    f ((a + m * d) + (i + 1) * d) = f (a + (m * d + (i + 1) * d)) := by
      simp [Nat.add_assoc]
    _ = f (a + ((m + i + 1) * d)) := by
      simp [hmul]

/-- Head+tail splitting normal form for affine sums, with the tail expressed as an `apSumOffset`
on the shifted sequence `k ↦ f (a + k)`.

This is a convenience wrapper around `apSumFrom_add_length` and
`apSumFrom_tail_eq_apSumOffset_shift` that puts the tail into the offset-sum nucleus API directly.
-/
lemma apSumFrom_add_length_eq_add_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSumOffset (fun k => f (a + k)) d m n := by
  calc
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSumFrom f (a + m * d) d n := by
      simpa using apSumFrom_add_length (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumFrom f a d m + apSumOffset (fun k => f (a + k)) d m n := by
      simp [apSumFrom_tail_eq_apSumOffset_shift]

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (a + k)`, with the
starting point written as `m*d + a`.

This wrapper avoids a manual commutativity rewrite of the affine start at the call site.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d n = apSumOffset (fun k => f (a + k)) d m n := by
  calc
    apSumFrom f (m * d + a) d n = apSumFrom f (a + m * d) d n := by
      simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
    _ = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Inverse orientation of `apSumFrom_tail_eq_apSumOffset_shift_start_add_left`. -/
lemma apSumOffset_shift_eq_apSumFrom_tail_start_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (a + k)) d m n = apSumFrom f (m * d + a) d n := by
  calc
    apSumOffset (fun k => f (a + k)) d m n = apSumFrom f (a + m * d) d n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n)).symm
    _ = apSumFrom f (m * d + a) d n := by
      simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]

/-- Affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (a + k)`.

This is the `m = 0` case of `apSumFrom_tail_eq_apSumOffset_shift`.
-/
lemma apSumFrom_eq_apSumOffset_shift (f : ℕ → ℤ) (a d n : ℕ) :
    apSumFrom f a d n = apSumOffset (fun k => f (a + k)) d 0 n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := 0) (n := n))

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is the same normal form as `apSumFrom_tail_eq_apSumOffset_shift`, but the shifted sequence is
written in the translation-friendly `k + a` form.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (k + a)) d m n := by
  have hshift : (fun k => f (a + k)) = (fun k => f (k + a)) := by
    funext k
    simpa using congrArg f (Nat.add_comm a k)
  simpa [hshift] using
    (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Translation-friendly variant of `apSumFrom_add_length_eq_add_apSumOffset_shift`, with the tail
expressed as an `apSumOffset` on the shifted sequence `k ↦ f (k + a)`.

This is a convenience wrapper around `apSumFrom_add_length` and
`apSumFrom_tail_eq_apSumOffset_shift_add`.
-/
lemma apSumFrom_add_length_eq_add_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSumOffset (fun k => f (k + a)) d m n := by
  calc
    apSumFrom f a d (m + n) = apSumFrom f a d m + apSumFrom f (a + m * d) d n := by
      simpa using apSumFrom_add_length (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumFrom f a d m + apSumOffset (fun k => f (k + a)) d m n := by
      simp [apSumFrom_tail_eq_apSumOffset_shift_add]

/-- Tail affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (k + a)`, with the
starting point written as `m*d + a`.

This is a convenience wrapper around `apSumFrom_tail_eq_apSumOffset_shift_add` that avoids a manual
commutativity rewrite of the affine start.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (m * d + a) d n = apSumOffset (fun k => f (k + a)) d m n := by
  -- Reassociate/commute the affine start into the `a + m*d` normal form.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Normal form: eliminate the tail parameter `m` by absorbing it into a translation constant.

Concretely, the affine tail sum `apSumFrom f (a + m*d) d n` can be rewritten as an offset sum
with `m = 0` on the further-shifted sequence `k ↦ f (k + (a + m*d))`.

This is a convenience wrapper around `apSumFrom_tail_eq_apSumOffset_shift_add` and
`apSumOffset_shift_add_eq_apSumOffset_shift_add`.
-/
lemma apSumFrom_tail_eq_apSumOffset_shift_add_zero_m (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (k + a)) d m n := by
      simpa using
        apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
      simpa using
        apSumOffset_shift_add_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)

/-- Normal form: eliminate the offset parameter `m` in the canonical affine difference
`apSumFrom f a d (m+n) - apSumFrom f a d m` by absorbing it into a translation constant.

This produces an `apSumOffset` tail with `m = 0` on the further-shifted sequence
`k ↦ f (k + (a + m*d))`.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift_add_zero_m (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumFrom f (a + m * d) d n := by
      simpa using
        apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumOffset (fun k => f (k + a)) d m n := by
      simpa using
        apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)
    _ = apSumOffset (fun k => f (k + (a + m * d))) d 0 n := by
      simpa using
        apSumOffset_shift_add_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)

/-- Inverse orientation of `apSumFrom_tail_eq_apSumOffset_shift`.

This is useful when you have already normalized into the shifted-sequence form
`apSumOffset (fun k => f (a + k)) …` but want to return to the affine nucleus API.
-/
lemma apSumOffset_shift_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (a + k)) d m n = apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Inverse orientation of `apSumFrom_tail_eq_apSumOffset_shift_add`.

This is useful when you have already normalized into the translation-friendly shifted-sequence
form `apSumOffset (fun k => f (k + a)) …` but want to return to the affine nucleus API.
-/
lemma apSumOffset_shift_add_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n = apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Variant of `apSumOffset_shift_add_eq_apSumFrom_tail` with the affine start written as `m*d + a`.

This wrapper avoids a commutativity rewrite at the call site.
-/
lemma apSumOffset_shift_add_eq_apSumFrom_tail_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n = apSumFrom f (m * d + a) d n := by
  -- Normalize the affine start from `a + m*d` to `m*d + a`.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumOffset_shift_add_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Affine AP sum as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is the `m = 0` case of `apSumFrom_tail_eq_apSumOffset_shift_add`.
-/
lemma apSumFrom_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d n : ℕ) :
    apSumFrom f a d n = apSumOffset (fun k => f (k + a)) d 0 n := by
  simpa using
    (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := 0) (n := n))

/-- Inverse orientation of `apSumFrom_eq_apSumOffset_shift_add`.

This is the `m = 0` case of `apSumOffset_shift_add_eq_apSumFrom_tail`.
-/
lemma apSumOffset_shift_add_eq_apSumFrom (f : ℕ → ℤ) (a d n : ℕ) :
    apSumOffset (fun k => f (k + a)) d 0 n = apSumFrom f a d n := by
  simpa using (apSumFrom_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (n := n)).symm

/-- Normal form: rewrite the canonical affine difference `(m+n) - m` as an offset AP sum on the
shifted sequence `k ↦ f (k + a)`.

This is the same normal form as `apSumFrom_sub_eq_apSumOffset_shift`, but in the translation-
friendly `k + a` form.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumOffset (fun k => f (k + a)) d m n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (k + a)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
                (n := n))

/-- Inverse orientation of `apSumFrom_sub_eq_apSumOffset_shift_add`.

This is a convenience normal form: if you already have an `apSumOffset` tail sum on the
translation-friendly shifted sequence `k ↦ f (k + a)`, you can rewrite it back into a
difference of affine partial sums.
-/
lemma apSumOffset_shift_add_eq_apSumFrom_sub (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n = apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Tail-of-tail normal form, expressed as an offset AP sum on the shifted sequence `k ↦ f (a + k)`.

This is the `apSumFrom` analogue of `apSumOffset_sub_eq_apSumOffset_tail`.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
  calc
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1
        = apSumFrom f (a + (m + n1) * d) d n2 := by
            simpa using
              (apSumFrom_tail_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m)
                (n1 := n1) (n2 := n2))
    _ = apSumOffset (fun k => f (a + k)) d (m + n1) n2 := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m + n1)
                (n := n2))

/-- Tail-of-tail normal form, expressed as an offset AP sum on the shifted sequence `k ↦ f (k + a)`.

This is the translation-friendly `k + a` variant of `apSumFrom_tail_sub_eq_apSumOffset_shift_tail`.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_add_tail (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (a + m * d) d (n1 + n2) - apSumFrom f (a + m * d) d n1 =
      apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
  have hshift : (fun k => f (a + k)) = (fun k => f (k + a)) := by
    funext k
    simpa using congrArg f (Nat.add_comm a k)
  simpa [hshift] using
    (apSumFrom_tail_sub_eq_apSumOffset_shift_tail (f := f) (a := a) (d := d) (m := m) (n1 := n1)
      (n2 := n2))

/-- Tail-of-tail normal form in the translation-friendly shifted-sequence form, with the affine
start written as `m*d + a`.

This wrapper avoids commuting `a + m*d` at the call site.
-/
lemma apSumFrom_tail_sub_eq_apSumOffset_shift_add_tail_start_add_left (f : ℕ → ℤ) (a d m n1 n2 : ℕ) :
    apSumFrom f (m * d + a) d (n1 + n2) - apSumFrom f (m * d + a) d n1 =
      apSumOffset (fun k => f (k + a)) d (m + n1) n2 := by
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumFrom_tail_sub_eq_apSumOffset_shift_add_tail (f := f) (a := a) (d := d) (m := m)
      (n1 := n1) (n2 := n2))

/-- Normal form: rewrite the canonical affine difference `(m+n) - m` as an offset AP sum on the
shifted sequence `k ↦ f (a + k)`.

This is the `apSumFrom` analogue of `apSum_sub_eq_apSumOffset`, oriented so that rewriting turns a
subtraction into an explicit `apSumOffset` tail.
-/
lemma apSumFrom_sub_eq_apSumOffset_shift (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m n := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Inverse orientation of `apSumFrom_sub_eq_apSumOffset_shift`.

This is a convenience normal form: if you already have an `apSumOffset` tail sum on the shifted
sequence `k ↦ f (a + k)`, you can rewrite it back into a difference of affine partial sums.
-/
lemma apSumOffset_shift_eq_apSumFrom_sub (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (a + k)) d m n = apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Rewrite the affine tail sum `apSumFrom f (a + m*d) d n` as the “paper notation” interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)`.

This is intended for surface statements: keep the nucleus API in terms of `apSumFrom` and use
this lemma only when matching paper notation.
-/
lemma apSumFrom_tail_eq_sum_Icc (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f (a + m * d) d n = apSumOffset (fun k => f (a + k)) d m n := by
      simpa using
        (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
      simpa using
        (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- Translation-friendly variant of `apSumFrom_tail_eq_sum_Icc`, with the summand written as
`f (i*d + a)` instead of `f (a + i*d)`.

This is useful when `simp`-normal forms or rewriting lemmas prefer `i*d + a`.
-/
lemma apSumFrom_tail_eq_sum_Icc_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f (a + m * d) d n =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) := by
  -- Start from the `a + i*d` version and normalize the summand.
  have h := apSumFrom_tail_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)
  -- `simp` can rewrite under the binder once we identify the two summand functions.
  have hsummand : (fun i => f (a + i * d)) = (fun i => f (i * d + a)) := by
    funext i
    simpa [Nat.add_comm] using congrArg f (Nat.add_comm a (i * d))
  simpa [hsummand] using h

/-- Normal form: rewrite the “paper notation” interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)` back to the affine tail sum `apSumFrom f (a + m*d) d n`.

This is useful when normalizing a surface statement into the nucleus API.
-/
lemma sum_Icc_eq_apSumFrom_tail (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Translation-friendly variant of `sum_Icc_eq_apSumFrom_tail`, with the summand written as
`f (i*d + a)` instead of `f (a + i*d)`.

This is the inverse orientation of `apSumFrom_tail_eq_sum_Icc_add`.
-/
lemma sum_Icc_eq_apSumFrom_tail_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) =
      apSumFrom f (a + m * d) d n := by
  simpa using
    (apSumFrom_tail_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Normal form (paper → nucleus, tail, translation-friendly): when `m ≤ n`, rewrite the interval sum
`∑ i ∈ Icc (m+1) n, f (i*d + a)` to the affine tail sum `apSumFrom f (a + m*d) d (n - m)`.

This is the `i*d + a` analogue of `sum_Icc_eq_apSumFrom_tail_of_le`.
-/
lemma sum_Icc_eq_apSumFrom_tail_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) =
      apSumFrom f (a + m * d) d (n - m) := by
  -- Put the interval endpoint into the canonical `(m + (n - m))` form and use the fixed-length lemma.
  simpa [Nat.add_sub_of_le hmn] using
    (sum_Icc_eq_apSumFrom_tail_add (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Split the “paper notation” affine interval sum
`∑ i ∈ Icc (m+1) (m+(n₁+n₂)), f (a + i*d)` into the first `n₁` terms and the next `n₂` terms.

This is the affine counterpart of `Discrepancy.sum_Icc_add_length`.
-/
lemma sum_Icc_add_length_affine (f : ℕ → ℤ) (a d m n₁ n₂ : ℕ) :
    (Finset.Icc (m + 1) (m + (n₁ + n₂))).sum (fun i => f (a + i * d)) =
      (Finset.Icc (m + 1) (m + n₁)).sum (fun i => f (a + i * d)) +
        (Finset.Icc (m + n₁ + 1) (m + n₁ + n₂)).sum (fun i => f (a + i * d)) := by
  -- Reduce to the non-affine splitting lemma by viewing `i ↦ f (a + i*d)` as the summand.
  simpa using
    (MoltResearch.sum_Icc_add_length (f := fun i => f (a + i)) (d := d) (m := m) (n₁ := n₁)
      (n₂ := n₂))

/-- Translation-friendly variant of `sum_Icc_add_length_affine`, with the summand written as
`f (i*d + a)` instead of `f (a + i*d)`.

This is useful when you want to avoid commuting `a + …` under binders.
-/
lemma sum_Icc_add_length_affine_add (f : ℕ → ℤ) (a d m n₁ n₂ : ℕ) :
    (Finset.Icc (m + 1) (m + (n₁ + n₂))).sum (fun i => f (i * d + a)) =
      (Finset.Icc (m + 1) (m + n₁)).sum (fun i => f (i * d + a)) +
        (Finset.Icc (m + n₁ + 1) (m + n₁ + n₂)).sum (fun i => f (i * d + a)) := by
  have h := sum_Icc_add_length_affine (f := f) (a := a) (d := d) (m := m) (n₁ := n₁) (n₂ := n₂)
  have hsummand : (fun i => f (a + i * d)) = (fun i => f (i * d + a)) := by
    funext i
    simpa [Nat.add_comm] using congrArg f (Nat.add_comm a (i * d))
  simpa [hsummand] using h

/-- Split the affine interval sum `∑ i ∈ Icc (m+1) n, f (a + i*d)` at an intermediate index `k`,
assuming `m ≤ k ≤ n`.

This is a convenience wrapper around `sum_Icc_add_length_affine` that avoids manual arithmetic
when your surface statement uses a variable upper endpoint.
-/
lemma sum_Icc_split_affine_of_le (f : ℕ → ℤ) (a d : ℕ) {m k n : ℕ}
    (hmk : m ≤ k) (hkn : k ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) =
      (Finset.Icc (m + 1) k).sum (fun i => f (a + i * d)) +
        (Finset.Icc (k + 1) n).sum (fun i => f (a + i * d)) := by
  have hupper : m + ((k - m) + (n - k)) = n := by
    calc
      m + ((k - m) + (n - k)) = (m + (k - m)) + (n - k) := by
        simp [Nat.add_assoc]
      _ = k + (n - k) := by
        simp [Nat.add_sub_of_le hmk, Nat.add_assoc]
      _ = n := by
        simp [Nat.add_sub_of_le hkn]
  calc
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d))
        = (Finset.Icc (m + 1) (m + ((k - m) + (n - k)))).sum (fun i => f (a + i * d)) := by
            simpa [hupper]
    _ = (Finset.Icc (m + 1) (m + (k - m))).sum (fun i => f (a + i * d)) +
          (Finset.Icc (m + (k - m) + 1) (m + (k - m) + (n - k))).sum
              (fun i => f (a + i * d)) := by
            simpa using
              (sum_Icc_add_length_affine (f := f) (a := a) (d := d) (m := m)
                (n₁ := k - m) (n₂ := n - k))
    _ = (Finset.Icc (m + 1) k).sum (fun i => f (a + i * d)) +
          (Finset.Icc (k + 1) n).sum (fun i => f (a + i * d)) := by
            -- Normalize endpoints using `m + (k - m) = k` and `k + (n - k) = n`.
            simp [Nat.add_sub_of_le hmk, Nat.add_sub_of_le hkn, Nat.add_assoc, Nat.add_left_comm,
              Nat.add_comm]

/-- Translation-friendly variant of `sum_Icc_split_affine_of_le`, with the summand written as
`f (i*d + a)` instead of `f (a + i*d)`.

This is useful when downstream normal forms are expressed in the `i*d + a` convention.
-/
lemma sum_Icc_split_affine_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m k n : ℕ}
    (hmk : m ≤ k) (hkn : k ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) =
      (Finset.Icc (m + 1) k).sum (fun i => f (i * d + a)) +
        (Finset.Icc (k + 1) n).sum (fun i => f (i * d + a)) := by
  have h := sum_Icc_split_affine_of_le (f := f) (a := a) (d := d) (m := m) (k := k) (n := n)
    (hmk := hmk) (hkn := hkn)
  have hsummand : (fun i => f (a + i * d)) = (fun i => f (i * d + a)) := by
    funext i
    simpa [Nat.add_comm] using congrArg f (Nat.add_comm a (i * d))
  simpa [hsummand] using h


/-- Normal form: when `m ≤ n`, rewrite the “paper notation” interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)` to the affine tail sum `apSumFrom f (a + m*d) d (n - m)`.

This is the affine analogue of `sum_Icc_eq_apSumOffset`.
-/
lemma sum_Icc_eq_apSumFrom_tail_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) =
      apSumFrom f (a + m * d) d (n - m) := by
  -- Put the interval endpoint into the canonical `(m + (n - m))` form and use
  -- `sum_Icc_eq_apSumFrom_tail`.
  simpa [Nat.add_sub_of_le hmn] using
    (sum_Icc_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Surface form: when `m ≤ n`, rewrite the affine tail sum `apSumFrom f (a + m*d) d (n - m)` as
an interval sum `∑ i ∈ Icc (m+1) n, f (a + i*d)`.

This is the affine analogue of `apSumOffset_eq_sum_Icc_of_le`.
-/
lemma apSumFrom_tail_eq_sum_Icc_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f (a + m * d) d (n - m) =
      (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Translation-friendly surface form: when `m ≤ n`, rewrite the affine tail sum
`apSumFrom f (a + m*d) d (n - m)` as an interval sum `∑ i ∈ Icc (m+1) n, f (i*d + a)`.

This is the `i*d + a` analogue of `apSumFrom_tail_eq_sum_Icc_of_le`.
-/
lemma apSumFrom_tail_eq_sum_Icc_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f (a + m * d) d (n - m) =
      (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) := by
  -- Convert to the fixed-length `(m + (n - m))` form, then use the fixed-length add-left lemma.
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_tail_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Difference of two affine AP partial sums as an offset AP sum on the shifted sequence
`k ↦ f (a + k)` when `m ≤ n`.

This is the affine analogue of `apSum_sub_apSum_eq_apSumOffset`.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (a + k)) d m (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m)
                (n := n - m))

/-- Difference of two affine AP partial sums as an offset AP sum on the shifted sequence
`k ↦ f (k + a)` when `m ≤ n`.

This is the same normal form as `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift`, but in the
translation-friendly `k + a` form.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (k + a)) d m (n - m) := by
  have hshift : (fun k => f (a + k)) = (fun k => f (k + a)) := by
    funext k
    simpa using congrArg f (Nat.add_comm a k)
  simpa [hshift] using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f := f) (a := a) (d := d) (hmn := hmn))

/-- Normal form: eliminate the offset parameter `m` in the affine difference
`apSumFrom f a d n - apSumFrom f a d m` (with `m ≤ n`) by absorbing it into the translation
constant.

This produces an `apSumOffset` tail with `m = 0` on the further-shifted sequence
`k ↦ f (k + (a + m*d))`.
-/
lemma apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_zero_m_of_le (f : ℕ → ℤ) (a d : ℕ)
    {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      apSumOffset (fun k => f (k + (a + m * d))) d 0 (n - m) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m = apSumOffset (fun k => f (k + a)) d m (n - m) := by
      simpa using
        (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
          (n := n) (hmn := hmn))
    _ = apSumOffset (fun k => f (k + (a + m * d))) d 0 (n - m) := by
      simpa using
        (apSumOffset_shift_add_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
          (n := n - m))

/-- Inverse orientation of `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_zero_m_of_le`. -/
lemma apSumOffset_shift_add_zero_m_eq_apSumFrom_sub_apSumFrom_of_le (f : ℕ → ℤ) (a d : ℕ)
    {m n : ℕ} (hmn : m ≤ n) :
    apSumOffset (fun k => f (k + (a + m * d))) d 0 (n - m) = apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add_zero_m_of_le (f := f) (a := a) (d := d)
      (m := m) (n := n) (hmn := hmn)).symm

/-- Inverse orientation of `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift`.

This is a convenience normal form: if you already have an `apSumOffset` tail sum on the shifted
sequence `k ↦ f (a + k)`, you can rewrite it back into a difference of affine partial sums.
-/
lemma apSumOffset_shift_eq_apSumFrom_sub_apSumFrom_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumOffset (fun k => f (a + k)) d m (n - m) = apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n)
      (hmn := hmn)).symm

/-- Inverse orientation of `apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add`.

This is a convenience normal form: if you already have an `apSumOffset` tail sum on the
translation-friendly shifted sequence `k ↦ f (k + a)`, you can rewrite it back into a difference
of affine partial sums.
-/
lemma apSumOffset_shift_add_eq_apSumFrom_sub_apSumFrom_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    apSumOffset (fun k => f (k + a)) d m (n - m) = apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_apSumOffset_shift_add (f := f) (a := a) (d := d) (m := m)
      (n := n) (hmn := hmn)).symm

/-- Rewrite the normal-form difference `apSumFrom f a d (m+n) - apSumFrom f a d m` as an
interval sum `∑ i ∈ Icc (m+1) (m+n), f (a + i*d)`.

This is intended for surface statements: keep the nucleus API in terms of `apSumFrom` and use
this lemma only when matching paper notation.
-/
lemma apSumFrom_sub_eq_sum_Icc (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f a d (m + n) - apSumFrom f a d m
        = apSumFrom f (a + m * d) d n := by
            simpa using
              (apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = apSumOffset (fun k => f (a + k)) d m n := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m) (n := n))
    _ = (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) := by
            simpa using
              (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- Translation-friendly surface form: rewrite the normal-form difference
`apSumFrom f a d (m+n) - apSumFrom f a d m` as an interval sum with summand written as
`f (i*d + a)`.

This is the `i*d + a` analogue of `apSumFrom_sub_eq_sum_Icc`.
-/
lemma apSumFrom_sub_eq_sum_Icc_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumFrom f a d (m + n) - apSumFrom f a d m =
      (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) := by
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_sub_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n))

/-- Inverse orientation of `apSumFrom_sub_eq_sum_Icc_add`. -/
lemma sum_Icc_eq_apSumFrom_sub_add (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (i * d + a)) =
      apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- When `m ≤ n`, rewrite `apSumFrom f a d n - apSumFrom f a d m` as an interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)`.

This is the “paper notation” counterpart of `apSumFrom_sub_apSumFrom_eq_apSumFrom`.
-/
lemma apSumFrom_sub_apSumFrom_eq_sum_Icc (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simpa using
              (apSumFrom_tail_eq_apSumOffset_shift (f := f) (a := a) (d := d) (m := m)
                (n := n - m))
    _ = (Finset.Icc (m + 1) (m + (n - m))).sum (fun i => f (a + i * d)) := by
            simpa using
              (apSumOffset_eq_sum_Icc (f := fun k => f (a + k)) (d := d) (m := m) (n := n - m))
    _ = (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) := by
            simp [Nat.add_sub_of_le hmn]

/-- Translation-friendly variant of `apSumFrom_sub_apSumFrom_eq_sum_Icc`, with the summand written
as `f (i*d + a)`.

This is useful when rewriting surface goals in a normal form compatible with downstream
translation lemmas.
-/
lemma apSumFrom_sub_apSumFrom_eq_sum_Icc_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n - apSumFrom f a d m =
      (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) := by
  calc
    apSumFrom f a d n - apSumFrom f a d m
        = apSumFrom f (a + m * d) d (n - m) := by
            simpa using
              (apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn))
    _ = (Finset.Icc (m + 1) (m + (n - m))).sum (fun i => f (i * d + a)) := by
            simpa using
              (apSumFrom_tail_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n - m))
    _ = (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) := by
            simp [Nat.add_sub_of_le hmn]

/-- Normal form (paper → nucleus, difference): rewrite the interval sum
`∑ i ∈ Icc (m+1) (m+n), f (a + i*d)` as the difference of affine AP partial sums.

This is the inverse orientation of `apSumFrom_sub_eq_sum_Icc`.
-/
lemma sum_Icc_eq_apSumFrom_sub (f : ℕ → ℤ) (a d m n : ℕ) :
    (Finset.Icc (m + 1) (m + n)).sum (fun i => f (a + i * d)) =
      apSumFrom f a d (m + n) - apSumFrom f a d m := by
  simpa using (apSumFrom_sub_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Normal form (paper → nucleus, difference): when `m ≤ n`, rewrite the interval sum
`∑ i ∈ Icc (m+1) n, f (a + i*d)` as a difference of affine AP partial sums.

This is the inverse orientation of `apSumFrom_sub_apSumFrom_eq_sum_Icc`.
-/
lemma sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (a + i * d)) =
      apSumFrom f a d n - apSumFrom f a d m := by
  simpa using (apSumFrom_sub_apSumFrom_eq_sum_Icc (f := f) (a := a) (d := d) (m := m) (n := n)
    hmn).symm

/-- Translation-friendly variant of `sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le`, with the summand
written as `f (i*d + a)`.

This is the inverse orientation of `apSumFrom_sub_apSumFrom_eq_sum_Icc_add`.
-/
lemma sum_Icc_eq_apSumFrom_sub_apSumFrom_of_le_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ}
    (hmn : m ≤ n) :
    (Finset.Icc (m + 1) n).sum (fun i => f (i * d + a)) =
      apSumFrom f a d n - apSumFrom f a d m := by
  simpa using
    (apSumFrom_sub_apSumFrom_eq_sum_Icc_add (f := f) (a := a) (d := d) (m := m) (n := n) hmn).symm

/-- Sign-sequence bound on `apSumFrom` in the `(m + n) - m` normal form. -/
lemma IsSignSequence.natAbs_apSumFrom_sub_le {f : ℕ → ℤ} (hf : IsSignSequence f)
    (a d m n : ℕ) :
    Int.natAbs (apSumFrom f a d (m + n) - apSumFrom f a d m) ≤ n := by
  have h := IsSignSequence.natAbs_apSumFrom_le (hf := hf) (a := a + m * d) (d := d) (n := n)
  have hEq := apSumFrom_sub_eq_apSumFrom_tail (f := f) (a := a) (d := d) (m := m) (n := n)
  simpa [hEq] using h

/-- Split an affine AP partial sum at `m` when `m ≤ n`. -/
lemma apSumFrom_eq_add_apSumFrom_tail (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n = apSumFrom f a d m + apSumFrom f (a + m * d) d (n - m) := by
  simpa [Nat.add_sub_of_le hmn] using
    (apSumFrom_add_length (f := f) (a := a) (d := d) (m := m) (n := n - m))

/-- Split an affine AP partial sum at `m` when `m ≤ n`, with the tail normalized into the
`apSumOffset` API on the shifted sequence `k ↦ f (a + k)`.

This is often the most composable normal form downstream: once the tail is an `apSumOffset`,
bounds/splitting/difference lemmas can be applied without carrying affine start bookkeeping.
-/
lemma apSumFrom_eq_add_apSumOffset_shift (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n =
      apSumFrom f a d m + apSumOffset (fun k => f (a + k)) d m (n - m) := by
  calc
    apSumFrom f a d n
        = apSumFrom f a d m + apSumFrom f (a + m * d) d (n - m) := by
            simpa using (apSumFrom_eq_add_apSumFrom_tail (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumFrom f a d m + apSumOffset (fun k => f (a + k)) d m (n - m) := by
            simp [apSumFrom_tail_eq_apSumOffset_shift]

/-- Split an affine AP partial sum at `m` when `m ≤ n`, with the tail normalized into the
`apSumOffset` API on the translation-friendly shifted sequence `k ↦ f (k + a)`.

This is often the most composable normal form downstream: once the tail is an `apSumOffset`,
bounds/splitting/difference lemmas can be applied without carrying affine start bookkeeping.
-/
lemma apSumFrom_eq_add_apSumOffset_shift_add (f : ℕ → ℤ) (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    apSumFrom f a d n =
      apSumFrom f a d m + apSumOffset (fun k => f (k + a)) d m (n - m) := by
  calc
    apSumFrom f a d n
        = apSumFrom f a d m + apSumFrom f (a + m * d) d (n - m) := by
            simpa using (apSumFrom_eq_add_apSumFrom_tail (f := f) (a := a) (d := d) (hmn := hmn))
    _ = apSumFrom f a d m + apSumOffset (fun k => f (k + a)) d m (n - m) := by
            simp [apSumFrom_tail_eq_apSumOffset_shift_add]

/-- Sign-sequence bound on the difference of two affine AP partial sums when `m ≤ n`. -/
lemma IsSignSequence.natAbs_apSumFrom_sub_apSumFrom_le {f : ℕ → ℤ} (hf : IsSignSequence f)
    (a d : ℕ) {m n : ℕ} (hmn : m ≤ n) :
    Int.natAbs (apSumFrom f a d n - apSumFrom f a d m) ≤ n - m := by
  have h := IsSignSequence.natAbs_apSumFrom_le (hf := hf) (a := a + m * d) (d := d) (n := n - m)
  have hEq := apSumFrom_sub_apSumFrom_eq_apSumFrom (f := f) (a := a) (d := d) (hmn := hmn)
  simpa [hEq] using h

end MoltResearch
