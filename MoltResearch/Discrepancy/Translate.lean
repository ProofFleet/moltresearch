import MoltResearch.Discrepancy.Affine
import MoltResearch.Discrepancy.Offset

/-!
# Discrepancy: translation (additive reindexing) lemmas

(Generated by Forge.)
-/

namespace MoltResearch

lemma apSumFrom_map_add (f : ℕ → ℤ) (k a d n : ℕ) :
  apSumFrom (fun x => f (x + k)) a d n = apSumFrom f (a + k) d n := by
  unfold apSumFrom
  refine Finset.sum_congr rfl ?_
  intro i hi
  simp [Nat.add_comm, Nat.add_assoc]

/-- Variant of `apSumFrom_map_add` for translated functions written in the `k + x` form.

This is occasionally convenient when the ambient goal prefers a “constant on the left” convention.
-/
lemma apSumFrom_map_add_left (f : ℕ → ℤ) (k a d n : ℕ) :
  apSumFrom (fun x => f (k + x)) a d n = apSumFrom f (k + a) d n := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  -- Reduce to `apSumFrom_map_add` and then normalize `a + k` ↔ `k + a`.
  simpa [hfun, Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_map_add (f := f) (k := k) (a := a) (d := d) (n := n))

lemma apSum_map_add (f : ℕ → ℤ) (k d n : ℕ) :
  apSum (fun x => f (x + k)) d n = apSumFrom f k d n := by
  calc
    apSum (fun x => f (x + k)) d n
        = apSumFrom (fun x => f (x + k)) 0 d n := by
            simpa using (apSum_eq_apSumFrom (f := fun x => f (x + k)) (d := d) (n := n))
    _ = apSumFrom f (0 + k) d n := by
            simpa using (apSumFrom_map_add (f := f) (k := k) (a := 0) (d := d) (n := n))
    _ = apSumFrom f k d n := by simp

/-- Variant of `apSum_map_add` for translated functions written in the `k + x` form. -/
lemma apSum_map_add_left (f : ℕ → ℤ) (k d n : ℕ) :
  apSum (fun x => f (k + x)) d n = apSumFrom f k d n := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  simpa [hfun] using (apSum_map_add (f := f) (k := k) (d := d) (n := n))

/-- Commute an additive translation under `apSum`.

This is a lightweight normal-form lemma: it lets you switch between the binder conventions
`fun k => f (a + k)` and `fun k => f (k + a)` without doing a manual `funext` rewrite.

We do *not* mark this as `[simp]`: it is intended as an explicit normalization step when you want
a translation-friendly `k + const` summand shape.
-/
lemma apSum_shift_comm (f : ℕ → ℤ) (a d n : ℕ) :
    apSum (fun k => f (a + k)) d n = apSum (fun k => f (k + a)) d n := by
  unfold apSum
  refine Finset.sum_congr rfl ?_
  intro i hi
  simp [Nat.add_comm]

/-- Commute an additive translation under `apSumFrom`.

This is the affine analogue of `apSum_shift_comm`: it lets you switch between the binder
conventions `fun x => f (a + x)` and `fun x => f (x + a)` without doing a manual `funext` rewrite.

We do *not* mark this as `[simp]`: it is intended as an explicit normalization step when you want
a translation-friendly `x + const` summand shape.
-/
lemma apSumFrom_shift_comm (f : ℕ → ℤ) (a k d n : ℕ) :
    apSumFrom (fun x => f (a + x)) k d n = apSumFrom (fun x => f (x + a)) k d n := by
  unfold apSumFrom
  refine Finset.sum_congr rfl ?_
  intro i hi
  simp [Nat.add_comm]

-- (moved to `Discrepancy/Affine.lean`)

lemma apSumOffset_map_add (f : ℕ → ℤ) (k d m n : ℕ) :
  apSumOffset (fun x => f (x + k)) d m n = apSumFrom f (m * d + k) d n := by
  calc
    apSumOffset (fun x => f (x + k)) d m n
        = apSumFrom (fun x => f (x + k)) (m * d) d n := by
            simpa using
              (apSumOffset_eq_apSumFrom (f := fun x => f (x + k)) (d := d) (m := m) (n := n))
    _ = apSumFrom f (m * d + k) d n := by
            simpa using (apSumFrom_map_add (f := f) (k := k) (a := m * d) (d := d) (n := n))

/-- Variant of `apSumOffset_map_add` with the affine start written in the `k + m*d` form.

This is a small normal-form lemma: it avoids a separate rewrite step commuting `m*d + k` into
`k + m*d` when you want the start parameter to match a “shift-then-offset” reading.
-/
lemma apSumOffset_map_add_start_add_left (f : ℕ → ℤ) (k d m n : ℕ) :
  apSumOffset (fun x => f (x + k)) d m n = apSumFrom f (k + m * d) d n := by
  have h := apSumOffset_map_add (f := f) (k := k) (d := d) (m := m) (n := n)
  -- Normalize the affine start parameter `m*d + k` into `k + m*d`.
  simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using h

/-- Variant of `apSumOffset_map_add` for translated functions written in the `k + x` form. -/
lemma apSumOffset_map_add_left (f : ℕ → ℤ) (k d m n : ℕ) :
  apSumOffset (fun x => f (k + x)) d m n = apSumFrom f (k + m * d) d n := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  -- Reduce to `apSumOffset_map_add` and then normalize `m*d + k` ↔ `k + m*d`.
  simpa [hfun, Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumOffset_map_add (f := f) (k := k) (d := d) (m := m) (n := n))

/-- Compose the “shift-add” translation `k ↦ k + a` with the offset-to-shift normal form.

This is a convenience lemma: it rewrites an offset sum on a shifted sequence
`apSumOffset (fun k => f (k + a)) d m n` into a homogeneous AP sum on a further-shifted sequence
with the *same* step size `d`.

The resulting summand is written in the translation-friendly `k + const` form.
-/
lemma apSumOffset_shift_add_eq_apSum_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n = apSum (fun k => f (k + (a + m * d))) d n := by
  -- Start from the generic offset → shifted-homogeneous normal form.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumOffset_eq_apSum_shift_add (f := fun k => f (k + a)) (d := d) (m := m) (n := n))

/-- Add-left variant of `apSumOffset_shift_add_eq_apSum_shift_add`.

This is the same convenience lemma, but in the `const + k` convention on the resulting `apSum`:

`apSumOffset (fun k => f (k + a)) d m n = apSum (fun k => f ((a + m*d) + k)) d n`.

This avoids an extra rewrite step commuting the translation constant under binders when your
surrounding development already prefers `const + x` summand shapes.
-/
lemma apSumOffset_shift_add_eq_apSum_shift_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n = apSum (fun k => f ((a + m * d) + k)) d n := by
  calc
    apSumOffset (fun k => f (k + a)) d m n
        = apSum (fun k => f (k + (a + m * d))) d n := by
            simpa using
              (apSumOffset_shift_add_eq_apSum_shift_add (f := f) (a := a) (d := d) (m := m)
                (n := n))
    _ = apSum (fun k => f ((a + m * d) + k)) d n := by
            simpa using (apSum_shift_comm (f := f) (a := a + m * d) (d := d) (n := n)).symm

/-- Inverse orientation of `apSumOffset_shift_add_eq_apSum_shift_add_left`. -/
lemma apSum_shift_add_left_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSum (fun k => f ((a + m * d) + k)) d n = apSumOffset (fun k => f (k + a)) d m n := by
  simpa using
    (apSumOffset_shift_add_eq_apSum_shift_add_left (f := f) (a := a) (d := d) (m := m)
      (n := n)).symm

/-- Add-left variant of `apSumOffset_shift_add_eq_apSum_shift_add`.

This is the same convenience lemma, but in the `a + k` convention:

`apSumOffset (fun k => f (a + k)) d m n = apSum (fun k => f ((a + m*d) + k)) d n`.

We keep both orientations available since `simp` often behaves better when we avoid commuting
addition under binders.
-/
lemma apSumOffset_shift_add_left_eq_apSum_shift_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (a + k)) d m n = apSum (fun k => f ((a + m * d) + k)) d n := by
  -- Start from the generic offset → shifted-homogeneous normal form (`m*d + k`) and reassociate.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumOffset_eq_apSum_shift (f := fun k => f (a + k)) (d := d) (m := m) (n := n))

/-- Inverse orientation of `apSumOffset_shift_add_eq_apSum_shift_add`.

This rewrites a homogeneous AP sum on a shifted sequence back into an `apSumOffset` on the
less-shifted sequence.
-/
lemma apSum_shift_add_eq_apSumOffset_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSum (fun k => f (k + (a + m * d))) d n = apSumOffset (fun k => f (k + a)) d m n := by
  simpa using
    (apSumOffset_shift_add_eq_apSum_shift_add (f := f) (a := a) (d := d) (m := m) (n := n)).symm

/-- Inverse orientation of `apSumOffset_shift_add_left_eq_apSum_shift_add_left`. -/
lemma apSum_shift_add_left_eq_apSumOffset_shift_add_left (f : ℕ → ℤ) (a d m n : ℕ) :
    apSum (fun k => f ((a + m * d) + k)) d n = apSumOffset (fun k => f (a + k)) d m n := by
  simpa using
    (apSumOffset_shift_add_left_eq_apSum_shift_add_left (f := f) (a := a) (d := d) (m := m)
      (n := n)).symm

lemma HasDiscrepancyAtLeast.of_map_add {f : ℕ → ℤ} {k C : ℕ} :
  HasDiscrepancyAtLeast (fun x => f (x + k)) C → HasAffineDiscrepancyAtLeast f C := by
  rintro ⟨d, n, hd, hgt⟩
  refine ⟨k, d, n, hd, ?_⟩
  simpa [apSum_map_add] using hgt

/-- Variant of `HasDiscrepancyAtLeast.of_map_add` for translated functions written in the `k + x`
form. -/
lemma HasDiscrepancyAtLeast.of_map_add_left {f : ℕ → ℤ} {k C : ℕ} :
  HasDiscrepancyAtLeast (fun x => f (k + x)) C → HasAffineDiscrepancyAtLeast f C := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  simpa [hfun] using (HasDiscrepancyAtLeast.of_map_add (f := f) (k := k) (C := C))

lemma HasAffineDiscrepancyAtLeast.of_map_add {f : ℕ → ℤ} {k C : ℕ} :
  HasAffineDiscrepancyAtLeast (fun x => f (x + k)) C → HasAffineDiscrepancyAtLeast f C := by
  rintro ⟨a, d, n, hd, hgt⟩
  refine ⟨a + k, d, n, hd, ?_⟩
  simpa [apSumFrom_map_add] using hgt

/-- Variant of `HasAffineDiscrepancyAtLeast.of_map_add` for translated functions written in the
`k + x` form. -/
lemma HasAffineDiscrepancyAtLeast.of_map_add_left {f : ℕ → ℤ} {k C : ℕ} :
  HasAffineDiscrepancyAtLeast (fun x => f (k + x)) C → HasAffineDiscrepancyAtLeast f C := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  simpa [hfun] using (HasAffineDiscrepancyAtLeast.of_map_add (f := f) (k := k) (C := C))

end MoltResearch
