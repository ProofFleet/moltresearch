import MoltResearch.Discrepancy.Affine

/-!
# Discrepancy: translation (additive reindexing) lemmas

(Generated by Forge.)
-/

namespace MoltResearch

lemma apSumFrom_map_add (f : ℕ → ℤ) (k a d n : ℕ) :
  apSumFrom (fun x => f (x + k)) a d n = apSumFrom f (a + k) d n := by
  unfold apSumFrom
  refine Finset.sum_congr rfl ?_
  intro i hi
  simp [Nat.add_comm, Nat.add_assoc]

/-- Variant of `apSumFrom_map_add` for translated functions written in the `k + x` form.

This is occasionally convenient when the ambient goal prefers a “constant on the left” convention.
-/
lemma apSumFrom_map_add_left (f : ℕ → ℤ) (k a d n : ℕ) :
  apSumFrom (fun x => f (k + x)) a d n = apSumFrom f (k + a) d n := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  -- Reduce to `apSumFrom_map_add` and then normalize `a + k` ↔ `k + a`.
  simpa [hfun, Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_map_add (f := f) (k := k) (a := a) (d := d) (n := n))

lemma apSum_map_add (f : ℕ → ℤ) (k d n : ℕ) :
  apSum (fun x => f (x + k)) d n = apSumFrom f k d n := by
  calc
    apSum (fun x => f (x + k)) d n
        = apSumFrom (fun x => f (x + k)) 0 d n := by
            simpa using (apSum_eq_apSumFrom (f := fun x => f (x + k)) (d := d) (n := n))
    _ = apSumFrom f (0 + k) d n := by
            simpa using (apSumFrom_map_add (f := f) (k := k) (a := 0) (d := d) (n := n))
    _ = apSumFrom f k d n := by simp

/-- Variant of `apSum_map_add` for translated functions written in the `k + x` form. -/
lemma apSum_map_add_left (f : ℕ → ℤ) (k d n : ℕ) :
  apSum (fun x => f (k + x)) d n = apSumFrom f k d n := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  simpa [hfun] using (apSum_map_add (f := f) (k := k) (d := d) (n := n))

/-- Convenience: rewrite `apSumFrom` as an `apSum` on the additively shifted function
`x ↦ f (x + a)`.

This is just `apSum_map_add` with the symmetry flipped. It can be handy when a goal is already
phrased as a translated homogeneous sum.
-/
lemma apSumFrom_eq_apSum_map_add (f : ℕ → ℤ) (a d n : ℕ) :
    apSumFrom f a d n = apSum (fun x => f (x + a)) d n := by
  simpa using (apSum_map_add (f := f) (k := a) (d := d) (n := n)).symm

/-- Variant of `apSumFrom_eq_apSum_map_add` where the translation is written in the `a + x` form.

This is occasionally convenient when downstream rewriting prefers a “constant on the left” normal
form (e.g. to match `simp [Nat.add_assoc]` patterns).
-/
lemma apSumFrom_eq_apSum_map_add_left (f : ℕ → ℤ) (a d n : ℕ) :
    apSumFrom f a d n = apSum (fun x => f (a + x)) d n := by
  have hfun : (fun x => f (x + a)) = fun x => f (a + x) := by
    funext x
    simp [Nat.add_comm]
  simpa [hfun] using (apSumFrom_eq_apSum_map_add (f := f) (a := a) (d := d) (n := n))

lemma apSumOffset_map_add (f : ℕ → ℤ) (k d m n : ℕ) :
  apSumOffset (fun x => f (x + k)) d m n = apSumFrom f (m * d + k) d n := by
  calc
    apSumOffset (fun x => f (x + k)) d m n
        = apSumFrom (fun x => f (x + k)) (m * d) d n := by
            simpa using
              (apSumOffset_eq_apSumFrom (f := fun x => f (x + k)) (d := d) (m := m) (n := n))
    _ = apSumFrom f (m * d + k) d n := by
            simpa using (apSumFrom_map_add (f := f) (k := k) (a := m * d) (d := d) (n := n))

/-- Variant of `apSumOffset_map_add` for translated functions written in the `k + x` form. -/
lemma apSumOffset_map_add_left (f : ℕ → ℤ) (k d m n : ℕ) :
  apSumOffset (fun x => f (k + x)) d m n = apSumFrom f (k + m * d) d n := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  -- Reduce to `apSumOffset_map_add` and then normalize `m*d + k` ↔ `k + m*d`.
  simpa [hfun, Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumOffset_map_add (f := f) (k := k) (d := d) (m := m) (n := n))

lemma HasDiscrepancyAtLeast.of_map_add {f : ℕ → ℤ} {k C : ℕ} :
  HasDiscrepancyAtLeast (fun x => f (x + k)) C → HasAffineDiscrepancyAtLeast f C := by
  rintro ⟨d, n, hd, hgt⟩
  refine ⟨k, d, n, hd, ?_⟩
  simpa [apSum_map_add] using hgt

lemma HasAffineDiscrepancyAtLeast.of_map_add {f : ℕ → ℤ} {k C : ℕ} :
  HasAffineDiscrepancyAtLeast (fun x => f (x + k)) C → HasAffineDiscrepancyAtLeast f C := by
  rintro ⟨a, d, n, hd, hgt⟩
  refine ⟨a + k, d, n, hd, ?_⟩
  simpa [apSumFrom_map_add] using hgt

end MoltResearch
