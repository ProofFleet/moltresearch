import MoltResearch.Discrepancy.Affine
import MoltResearch.Discrepancy.Offset

/-!
# Discrepancy: translation (additive reindexing) lemmas

(Generated by Forge.)
-/

namespace MoltResearch

lemma apSumFrom_map_add (f : ℕ → ℤ) (k a d n : ℕ) :
  apSumFrom (fun x => f (x + k)) a d n = apSumFrom f (a + k) d n := by
  unfold apSumFrom
  refine Finset.sum_congr rfl ?_
  intro i hi
  simp [Nat.add_comm, Nat.add_assoc]

/-- Variant of `apSumFrom_map_add` for translated functions written in the `k + x` form.

This is occasionally convenient when the ambient goal prefers a “constant on the left” convention.
-/
lemma apSumFrom_map_add_left (f : ℕ → ℤ) (k a d n : ℕ) :
  apSumFrom (fun x => f (k + x)) a d n = apSumFrom f (k + a) d n := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  -- Reduce to `apSumFrom_map_add` and then normalize `a + k` ↔ `k + a`.
  simpa [hfun, Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumFrom_map_add (f := f) (k := k) (a := a) (d := d) (n := n))

lemma apSum_map_add (f : ℕ → ℤ) (k d n : ℕ) :
  apSum (fun x => f (x + k)) d n = apSumFrom f k d n := by
  calc
    apSum (fun x => f (x + k)) d n
        = apSumFrom (fun x => f (x + k)) 0 d n := by
            simpa using (apSum_eq_apSumFrom (f := fun x => f (x + k)) (d := d) (n := n))
    _ = apSumFrom f (0 + k) d n := by
            simpa using (apSumFrom_map_add (f := f) (k := k) (a := 0) (d := d) (n := n))
    _ = apSumFrom f k d n := by simp

/-- Variant of `apSum_map_add` for translated functions written in the `k + x` form. -/
lemma apSum_map_add_left (f : ℕ → ℤ) (k d n : ℕ) :
  apSum (fun x => f (k + x)) d n = apSumFrom f k d n := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  simpa [hfun] using (apSum_map_add (f := f) (k := k) (d := d) (n := n))

-- (moved to `Discrepancy/Affine.lean`)

lemma apSumOffset_map_add (f : ℕ → ℤ) (k d m n : ℕ) :
  apSumOffset (fun x => f (x + k)) d m n = apSumFrom f (m * d + k) d n := by
  calc
    apSumOffset (fun x => f (x + k)) d m n
        = apSumFrom (fun x => f (x + k)) (m * d) d n := by
            simpa using
              (apSumOffset_eq_apSumFrom (f := fun x => f (x + k)) (d := d) (m := m) (n := n))
    _ = apSumFrom f (m * d + k) d n := by
            simpa using (apSumFrom_map_add (f := f) (k := k) (a := m * d) (d := d) (n := n))

/-- Variant of `apSumOffset_map_add` for translated functions written in the `k + x` form. -/
lemma apSumOffset_map_add_left (f : ℕ → ℤ) (k d m n : ℕ) :
  apSumOffset (fun x => f (k + x)) d m n = apSumFrom f (k + m * d) d n := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  -- Reduce to `apSumOffset_map_add` and then normalize `m*d + k` ↔ `k + m*d`.
  simpa [hfun, Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using
    (apSumOffset_map_add (f := f) (k := k) (d := d) (m := m) (n := n))

/-- Compose the “shift-add” translation `k ↦ k + a` with the offset-to-shift normal form.

This is a convenience lemma: it rewrites an offset sum on a shifted sequence
`apSumOffset (fun k => f (k + a)) d m n` into a homogeneous AP sum on a further-shifted sequence
with the *same* step size `d`.

The resulting summand is written in the translation-friendly `k + const` form.
-/
lemma apSumOffset_shift_add_eq_apSum_shift_add (f : ℕ → ℤ) (a d m n : ℕ) :
    apSumOffset (fun k => f (k + a)) d m n = apSum (fun k => f (k + (a + m * d))) d n := by
  -- Start from the generic offset → shifted-homogeneous normal form.
  simpa [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
    (apSumOffset_eq_apSum_shift_add (f := fun k => f (k + a)) (d := d) (m := m) (n := n))

lemma HasDiscrepancyAtLeast.of_map_add {f : ℕ → ℤ} {k C : ℕ} :
  HasDiscrepancyAtLeast (fun x => f (x + k)) C → HasAffineDiscrepancyAtLeast f C := by
  rintro ⟨d, n, hd, hgt⟩
  refine ⟨k, d, n, hd, ?_⟩
  simpa [apSum_map_add] using hgt

/-- Variant of `HasDiscrepancyAtLeast.of_map_add` for translated functions written in the `k + x`
form. -/
lemma HasDiscrepancyAtLeast.of_map_add_left {f : ℕ → ℤ} {k C : ℕ} :
  HasDiscrepancyAtLeast (fun x => f (k + x)) C → HasAffineDiscrepancyAtLeast f C := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  simpa [hfun] using (HasDiscrepancyAtLeast.of_map_add (f := f) (k := k) (C := C))

lemma HasAffineDiscrepancyAtLeast.of_map_add {f : ℕ → ℤ} {k C : ℕ} :
  HasAffineDiscrepancyAtLeast (fun x => f (x + k)) C → HasAffineDiscrepancyAtLeast f C := by
  rintro ⟨a, d, n, hd, hgt⟩
  refine ⟨a + k, d, n, hd, ?_⟩
  simpa [apSumFrom_map_add] using hgt

/-- Variant of `HasAffineDiscrepancyAtLeast.of_map_add` for translated functions written in the
`k + x` form. -/
lemma HasAffineDiscrepancyAtLeast.of_map_add_left {f : ℕ → ℤ} {k C : ℕ} :
  HasAffineDiscrepancyAtLeast (fun x => f (k + x)) C → HasAffineDiscrepancyAtLeast f C := by
  have hfun : (fun x => f (k + x)) = fun x => f (x + k) := by
    funext x
    simp [Nat.add_comm]
  simpa [hfun] using (HasAffineDiscrepancyAtLeast.of_map_add (f := f) (k := k) (C := C))

end MoltResearch
